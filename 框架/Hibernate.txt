ORM
	Object/Relationship Mapping :对象/关系映射
	利用面向对象思想编写的数据库应用程序,最终都是要把对象信息保存在关系型数据库中
	于是就要编写很多和底层数据库相关的SQL语句,而这样就与面向对象的思想格格不入

	写SQL语句的缺点:
	1.不同的数据库使用的SQL语法不同,如:PL/SQL与T/SQL
	2.同样的功能在不同的数据库中有不同的实现方式,比如实现分页的SQL
	3.程序过于依赖SQL,会对程序的移植以及扩展,维护等带来很大的麻烦

	所以就要使用ORM框架技术,来让程序员抛弃书写SQL的思想,完全适用面向对象的思想开发软件

Hibernate简介
	Hibernate是java领域的一款开源的ORM框架技术
	Hibernate框架对JDBC进行了非常轻量级的对象封装

	其他ORM框架技术:
	MyBatis  Toplink   EJB

Hibernate缓存机制
	三种级别
	1.事物级--基于session的生命周期，session创建开始到session销毁结束
	2.应用级--应用中或应用中某个独立数据库访问的共享缓存，多个事务共享
	3.分布式级--在多个应用实例，多个JVM之间共享的缓存。由多个应用级缓存组成

	hibernate中实现了二级缓存，一级缓存为事务级缓存，二级为应用级或分布式级。
	一级缓存由hibernate管理，无需干预。二级缓存为sessionFactory级别的，在应用范围或集群范围

	缓存是以map的形式进行存储的(key-id,value-object)


	一级缓存(Session):

	事务范围，每个事务(Session)都有单独的第一级缓存.

	一级缓存的管理：当应用程序调用Session的save()、update()、saveOrUpdate()、get()或load()，
	以及调用查询接口的 list()、iterate()--(用的是n+1次查询，先查id)或filter()方法时，
	如果在Session缓存中还不存在相应的对象，Hibernate就会把该对象加入到第一级缓存中。
	当清理缓存时，Hibernate会根据缓存中对象的状态变化来同步更新数据库。 
	Session为应用程序提供了两个管理缓存的方法： 
	evict(Object obj)：从缓存中清除参数指定的持久化对象。 
	clear()：清空缓存中所有持久化对象,flush():使缓存与数据库同步。

	当查询相应的字段如(name)，而不是对象时，不支持缓存。

	二级缓存(SessionFactory):

	Hibernate的二级缓存策略的一般过程如下：

	1:条件查询的时候，总是发出一条select * from table_name where …. （选择所有字段）
	这样的SQL句查询数据库，一次获得所有的数据对象(这个问题要考虑，如果你查询十万条数据时，内存不是被占用)。
	2:把获得的所有数据对象根据ID放入到第二级缓存中。
	3: 当Hibernate根据ID访问数据对象的时候，首先从Session一级缓存中查；
	查不到，如果配置了二级缓存，那么从二级缓存中查；查不到，再查询数据库，把结果按照ID放入到缓存。
	4:删除、更新、增加数据的时候，同时更新缓存。
	Hibernate的二级缓存策略，是针对于ID查询的缓存策略，
	对于条件查询则毫无作用。为此，Hibernate提供了针对条件查询的Query Cache。

	适用二级缓存的：
	1.很少被修改的数据
	2.不是很重要的数据，允许出现偶尔并发的数据
	3.不会被并发访问的数据
	4.参考数据,指的是供应用参考的常量数据，它的实例数目有限，
	它的实例会被许多其他类的实例引用，实例极少或者从来不会被修改。

	不适用二级缓存的：
	1 经常被修改的数据
	2 财务数据，绝对不允许出现并发
	3 与其他应用共享的数据。

	常用缓存插件：
	EhCache：可作为进程范围的缓存，存放数据的物理介质可以是内存或硬盘，对Hibernate的查询缓存提供了支持。
	OSCache：可作为进程范围的缓存，存放数据的物理介质可以是内存或硬盘，
	提供了丰富的缓存数据过期策略，对Hibernate的查询缓存提供了支持。
	SwarmCache：可作为群集范围内的缓存，但不支持Hibernate的查询缓存。
	JBossCache：可作为群集范围内的缓存，支持事务型并发访问策略，对Hibernate的查询缓存提供了支持。

	配置二级缓存的主要步骤：
	1 选择需要使用二级缓存的持久化类，设置它的命名缓存的并发访问策略。这是最值得认真考虑的步骤。
	2 选择合适的缓存插件，然后编辑该插件的配置文件。