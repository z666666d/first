1.导入静态成员
	语法 import static xxxx.xxx.xx.x

2.自动装箱和自动拆箱
	在将基本数据类型添加到集合时，编译器会自动将基本数据类型转换成包装类对象。再传递给集合
	可以将包装类对象赋值给一个基本数据类型变量，编译器会自动拆箱

	细节：
	boolean值、byte值、介于-128到127之间的short与int值，以及介于\u0000到\u007F之间的char值
	这些值的包装类对象会被高速缓存，重复使用，并且作为一般对象使用。因此这些对象的值相同，那么是同一个对象

3.可变参数
	可变参数定义语法：变量类型 ... 变量名
	调用可变参数方法时，编译器将自动创建一个数组保存传递给方法的可变参数
	因此，可以再方法体中以数组的形式访问可变参数
	在方法参数列表中只能有一个可变参数，且可变参数必须在参数列表的最后一个

4.枚举
	在一些方法中，他需要的数据不能是任意的，而必须是一定范围内的值
	使用enum关键字，可以定义一个枚举类。一个枚举也可以有构造函数、字段和方法

	在枚举类中直接定义枚举值：
	enum 枚举类名{
		A,B,C,D,E;//声明的每一个枚举值代表该枚举类的一个实例对象。相当于public static 枚举类 A= new 枚举类（）；
	}
	注意:枚举值必须定义在第一行
	
	构造方法：
	注意：构造方法必须是私有的。
	如果需要传入参数，直接写在枚举实例后面
	如：A（参数），B（参数）...

	抽象方法：
	当一个方法在不同的枚举下返回的值不同，这时就要定义一个抽象类。
	定义抽象方法，然后通过每个枚举实例的匿名内部类来实现抽象方法。
	如：A{
		实现方法
	}；

	常用方法：
	所有的枚举类都是java.lang.Enum类的子类,继承了他所有的方法

	name()		获取枚举对象的字符串名称
	ValueOf()	通过枚举的字符串名称获取枚举对象
	ordinal()	返回此枚举常量的序数(在枚举声明中的位置,从0开始)
	values()	返回枚举类中的所有枚举值.返回值为数组形式(API中没有该方法)

5.内省机制
	操作属性的,即get和set方法

	通过java.beans.Introspector类的getBeanInfo(class)方法
	将类对象作为参数传入,获取封装了该类属性的BeanInfo对象

	通过BeanInfo对象调用getPropertyDescriptors()方法可以得到该类所有的属性描述器对象
	属性描述器对象也可以通过构造方法直接new  PropertyDescriptor("字段名",类对象)

	getName()方法,得到属性名称  如:getClass()属性的名称为class,getClass()方法继承自Object类
	通过属性描述器调用getReadMethod()方法就可以的到指定字段的get方法对象
	通过getWriteMethod()方法可以得到指定字段的set方法对象

	通过方法对象调用invoke(obj,参数)方法就可以操作属性方法了

	BeanUtils工具包   必须和common-logging包同时使用
	通过getProperty(obj,字段名)可以直接获取字段的值,相当于get方法
	通过setProperty(obj,字段名,值)可以直接设置字段的值,相当于set方法

	BeanUtils可以进行自动类型转换,但仅限于基本数据类型.如:需要int型,而参数是字符串类型,是可以的

	如果不是基本类型,需要注册类型转换器
	ConvertUtils.register(convert,class)
	第一个参数为类型转换器对象,第二个是需要转换成的类型
	类型转换器对象可以直接使用Converter接口已有的实现类,也可以自己写converter对象的实现

6.泛型
	

