---
typora-root-url: ..\img
---

#第一章 走进Java

##1.1 java的技术体系

1.广义上讲

​	Java、Clojure、JRuby、Groovy等运行于Java虚拟机上的语言及其相关的程序都属于Java技术体系中的一员。

2.传统意义来讲

​	Sun官方定义的技术体系包括：

​		1.Java程序设计语言

​		2.各种硬件平台上的Java虚拟机

​		3.Class文件格式

​		4.Java API类库

​		5.来自商业机构和开源社区的第三方Java类库

​	其中，Java程序设计语言、Java虚拟机、Java API三部分可以统称为JDK（Java Development Kit/Java软件开发工具包），JDK是支持Java程序开发的最小环境。另外可以将Java API类库中Java SE API子集和Java虚拟机这两部分统称为JRE（Java Runtime Environment/Java运行环境，JRE是支持Java程序运行的标准环境。

![java虚拟机图片1](/java虚拟机图片1.jpg)				



3.按照重点业务领域划分:

- Java Card:支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台。
- Java ME（Micro Edition）：支持Java程序运行在移动终端（手机、PAD）上的平台。对Java API有所精简，并加入了针对移动终端的支持，这个版本以前称为J2ME。
- Java SE（Standard Edition）：支持面向桌面级应用（如Windows下的应用程序）的Java平台。提供了完整的Java核心API，这个版本以前称为J2SE。
- Java EE（Enterprise Edition）：支持使用多层架构的企业应用（如ERP、CRM应用）的Java平台。除了提供Java SE API外，还对其做了大量的扩充并提供了相关的部署支持，这个版本以前称为J2EE。

##1.2 Java虚拟机

###1.Sun Classic VM

​	世界上第一款商用Java虚拟机。在JDK1.0中发布，只能使用纯解释器的方式来执行Java代码。要使用JIT编译器，就必须进行外挂。如果外挂了JIT编译器，JIT编译器就完全接管虚拟机的执行系统，解释器不在工作。

​	外挂的JIT编译器包括sunwjit、symantee JIT、shuJIT等。

​	由于解释器和编译器无法配合工作，如果使用编译器执行代码就需要对每一行代码进行编译，迫于响应时间的压力，这些编译器不能使用编译耗时较高的优化技术。因此这个阶段的虚拟机即使使用JIT编译器输出的本地代码，执行效率也和传统的C\C++相比有很大的差距。

###2.Exact VM

​	由于Classic VM的各种问题，sun的虚拟机团队在JDK1.2的solaris平台上发布过一款名为Exact VM的虚拟机。这款虚拟机已经具备了现代高性能虚拟机的雏形，如两级即使编译器、编译器与解释器混合工作模式等。该虚拟机因使用准确式内存管理（Exact Memory Management，也可以叫Non-Conservative/Accurate Memory Management）而得名。

​	准确式内存管理，即虚拟机可以知道内存中某个位置的数据具体是什么类型。如内存中有一个32位的整数123456，虚拟机能够准确地知道这个整数是一个数值为123456的整数还是一个reference类型的指向123456的内存地址。这样虚拟机就能在GC时准确判断堆上的数据是否还可能被使用。

​	由于使用了准确式内存管理，Exact VM抛弃了Classic VM基于handler的对象查找方式，这样每次定位对象都少了一次间接查找的开销，提升了执行的性能。

​	Classic VM使用基于handler的对象查找方式的原因是由于在进行FGC之后对象可能被移动，如果地址为123456的对象被移动到了654321地址，由于不知道内存中数据的类型，不知道哪些123456是reference的前提下，虚拟机不敢贸然把所有的123456改为654321，所以要使用句柄来保证reference的稳定性。

###3.HotSpot VM

​	虽然Exact VM有了很大的进步，但是只存在了很短暂的时间就被更优秀的HotSpot VM取代了。HotSpot VM在JDK1.2 中作为备选方案与classic VM、Exact VM共存，在JDK 1.3中取代Classic VM成为了默认虚拟机。

​	HotSpot VM是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用最广泛的Java虚拟机。HotSpot VM来自于一家名为Longview Technologies的小公司，后被Sun公司收购。

​	HotSpot VM继承了Sun公司前两款商用虚拟机的优点，如准确式内存管理等。也有许多自己新的技术优势，如热点代码探测技术。

​	HotSpot VM的热点代码探测技术可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以方法为单位进行编译。如果一个方法被频繁的调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。通过编译器和解释器恰当的协同工作，可以再最优化的程序响应时间与最佳执行性能中取得平衡，且无需等待本地代码输出才能执行程序。编译的时间压力也相对减小，有助于引入更多的代码优化技术，输出质量更高的本地代码。

### 4.sun公司的其他虚拟机

​	除了上面的服务器、桌面领域的商用虚拟机外，还在移动端、嵌入式市场发布过虚拟机产品。另外还有一类虚拟机仅仅作为研究、验证某种技术和观点，或者作为一些规范的标准实现而出现的不以商用为目的的虚拟机。

（1）KVM

​	强调简单、轻量、高度可移植，但运行速度较慢。在Android、iOS等手机平台上曾经得到广泛的应用。

（2）CDC/CLDC HotSpot VM

​	它希望在手机、电子书、PAD等设备上建立统一的Java编程接口，是整个Java ME的重要支柱。但是从目前Android、iOS二分天下来看，局面并不乐观。

（3）Squawk VM

​	运行于Sun SPOT（一种手持WiFi设备）和Java Card上。是一个Java代码比重很高的嵌入式虚拟机实现，其中类加载器、字节码验证器、垃圾收集器、解释器、编译器和线程调度都是Java语言来完成的，仅靠C语言来编写设备I/O和必要的本地代码。

（4）JavaInJava

​	一个实验性质的虚拟机。试图以Java语言来实现Java程序的运行环境。他必须运行在另一个宿主虚拟机上，内部没有JIT编译器，代码只能以解释器模式执行。在当时（20世纪末）主流虚拟机都存在性能问题，所以这款虚拟机的执行速度可想而知。

（5）Maxine VM

​	与JavaInJava非常相似。他几乎也全部都是以Java代码实现（只有用于启动JVM的加载器使用C语言编写）。比起JavaInJava，它有先进的JIT编译器和垃圾收集器，但是没有解释器。可在宿主模式或独立模式下执行，其执行效率已经接近了HotSopt Client VM的水平。

###5.JRockit VM/J9 VM

​	除了Sun之外，还有其他一些组织、公司也研发过不少的虚拟机实现。其中就最著名、规模最大的属于BEA和IBM。

（1）JRockit VM

​	BEA公司2002年从Appeal Virtual Machines公司收购的虚拟机，曾经号称世界上速度最快的Java虚拟机。BEA将其发展为专门为服务器硬件和服务器端应用场景高度优化的虚拟机。由于专注于服务器端应用，它不太关注程序启动速度，内部不包含解析器实现，所有代码都依靠即时编译器编译后执行。

​	此外，JRockit VM的垃圾收集器和MissionControl服务套件等部分的实现，在众多Java虚拟机中也一直处于领先水平。

（2）J9 VM

​	属于IBM公司，虽然不是IBM公司唯一的一款虚拟机，不过是目前IBM公司主力发展的虚拟机。与JRockit VM专注于服务端应用不同，J9 VM的市场定位与HotSpot比较接近，是一款设计上从服务器端到桌面应用再到嵌入式都全面考虑的多用途虚拟机。

​	J9 VM开发的目的是作为IBM公司各种Java产品的执行平台，它的主要市场是和IBM产品（如WebSphere等）搭配以及在IBM AIX和z/OS这些平台上部署的Java应用。

### 6.Azul VM/BEA Liquid VM

​	我们平时所说的高性能虚拟机是指HotSpot、JRockit、J9这些通用平台上的虚拟机，实际上还有一类特定硬件平台专有的虚拟机，这些才是高性能的武器。

（1）Azul VM

​	Azul Systems公司在HotSpot基础上进行了大量的改进，运行于该公司专有硬件Vega系统上的Java虚拟机。每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控GC时间的垃圾收集器，为专有硬件优化的线程调度等优秀特性。后来Azul Systems发布了Zing JVM，可以再通用x86平台上提供接近于Vega系统的特性。

（2）Liquid VM

​	是BEA公司开发，可以直接运行在自家Hypervisor系统上的JRickit VM的虚拟化版本，Liquid VM不需要操作系统的支持，自身实现了一个专用操作系统的必要功能，如文件系统、网络支持等。有虚拟机越过操作系统直接控制硬件，可以获得诸多好处，如线程调度时，不需要再进行内核态/用户态的切换，最大限度地发挥硬件能力，提升Java程序的执行效率。

###7.Harmony/Android Dalvik VM

（1）Harmony

​	Apache软件基金会旗下以Apache License协议开源的实际兼容于JDK1.5和JDK1.6的Java程序运行平台。它包含自己的虚拟机和Java库，可以在上面运行Eclipse、Tomcat、Maven等常见Java程序。可以说是Apache的JDK，但是由于没有通过TCK的兼容性测试而不能这样说。

​	虽然没有大规模商用，但是很多代码被吸纳进了IBM的JDK 7实现以及Google Android SDK中，尤其对Android的发展起到了很大的推动作用。

（2）Dalvik VM

​	Android让Java语言真正走进移动设备领域，虽然走的并非是sun公司原本想象的那条路。Dalvik VM是Android平台的核心组成部分之一。

​	Dalvik VM并不是一个Java虚拟机，他没有遵循Java虚拟机规范，不能直接执行Class文件。使用的是寄存器架构而不是JVM中常见的栈架构。但它又与Java有千丝万缕的联系，它执行的dex文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。

###8.Microsoft JVM

​	微软公司开发的虚拟机，是当时Windows下性能最好的Java虚拟机。主要应用之一是在浏览器中运行Java Applets程序，但是由于微软公司出于将Java绑定在Windows系统上的目的，与Java设计的初衷不符，导致sun公司与微软公司的官司，微软最终在Windows系统中彻底移除了对Java语言的支持。

### 9.其他

除了上述提到的虚拟机外，还有大量的Java虚拟机，如：

- JamVM
- cacaovm
- SableVM
- Kaffe
- Jelatine JVM
- NanoVM
- MRP
- Moxie JVM
- Jikes RVM
- 等等

##1.3 Java语言未来展望

###1.模块化

​	模块化是解决应用系统与技术平台越来越复杂、越来越庞大问题的一个重要途径。模块化已经在Java9中发布

###2.混合语言

​	当单一的Java开发已经无法满足当前软件的复杂需求时，越来越多基于Java虚拟机的语言开发被应用到软件项目中，Java平台上的多语言混合编程正在成为主流，每种语言都可以针对自己擅长的方面更好地解决问题。通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂项目需求的一个方向。

​	除了出现了大量运行于Java虚拟机的新语言之外，很多常见的语言也出现了基于Java虚拟机的实现版本，如C、PHP、Ruby、JavaScript、Python等等。

​	对于这些运行于Java虚拟机上的Java之外的语言，来自系统级、底层的支持也正在迅速增强，以JSR-292为核心的一系列项目和功能改进，正在推动Java虚拟机从Java语言的虚拟机向多语言的虚拟机转变。

###3.多核并行

​	CPU的发展已经从高频率转向多核心，随着多核时代的到来，软件开发越来越关注并行编程的领域。JDK1.5中java.util.concurrent包实现了一个粗粒度的并发框架。JDK1.7中java.util.concurrent.forkjoin包则对并发框架进行了重要的扩充。Fork/Join模式是一个处理并发编程的经典方法，虽然不能解决所有问题，但是在该模式适用的范围内，能够轻松的利用多个CPU核心提供的计算资源来协作完成一个复杂的计算任务。Fork/Join模式使我们能够顺利的过渡到多核时代。

​	Java8中提供Lambda表达式，极大的改善了Java语言不适合函数式编程的现状（在Lambda表达式出现之前，Java是通过内部类的形式实现函数式编程的，但是这样会使程序显得过于臃肿）。函数式编程的一个重要优点就是这样的程序天然适合并行运行，这对Java语言在多核时代继续保持主流语言的地位有很大的帮助。

​	目前显卡的算术运算能力、并行能力已经远远超过了CPU，在图形领域以外发掘显卡的潜力是近几年计算机发展的方向之一。OpenJDK的Sumatra子项目就是为Java提供GPU和APU运算能力的工具。以后它将会提供Java语言层面的API，或者为Lambda和其他JVM语言提供底层的并行运算支持。

​	此外还有一些如Hadoop Map Reduce等框架，运行于大型集群上以一种可靠地容错方式并行处理TB级别以上的数据集、另外，还有一些如Scala、Clojure、Erlang等天生就具备并行计算能力的语言。

###4.进一步丰富语法

在OpenJDK中建立的子项目Coin就是为了处理Java语法的细节修改。、

###5.64位虚拟机

虽然Java很早就推出了64位虚拟机，但是Java程序运行在64位虚拟机上需要付出较大的额外代价：

1.由于指针膨胀和各种数据类型对其补白的原因，Java程序运行于64位虚拟机上通常要多消耗10%~30%的内存。

2.64位虚拟机在运行速度上各个测试项几乎都落后于32位虚拟机，存在大约15%的性能差距。

所以64位Java虚拟机还需要进一步完善。



#第二章 Java内存区域与内存溢出异常

​	Java与C++相比具有内存动态分配和垃圾回收机制，在虚拟机自动内存管理机制下，Java程序不容易出现内存泄漏和内存溢出的问题。但是正是因为这个原因，如果出现了内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么将很难排查错误。

##2.1 运行时数据区域

![java虚拟机图片2](/java虚拟机图片2.jpg)

​	Java虚拟机在执行Java程序过程中，会把它所管理的内存划分为若干个不同的数据区域。这些数据区域都有各自的用途及生命周期。有的区域随虚拟机进程启动而存在，有些区域依赖于用户线程的启动和结束。Java的运行时内存区域大致可分为：虚拟机栈、本地方法栈、程序计数器、方法区、堆五个区域。其中方法区、堆是线程共享的数据区域。

###2.1.1 程序计数器

​	是一块较小的内存空间，可以看作是当前线程所执行字节码的行号指示器。

​	在虚拟机概念模型里，字节码解释器工作时就是通过改变计数器中的数值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等都需要依赖于这个计数器来完成。（只是概念模型，各个虚拟机可能会通过更高效的方式实现）

​	由于Java多线程会在多个线程中轮流切换执行，当线程恢复运行时，为了能恢复到正确的位置，每个线程都需要一个独立的计数器，使各个线程之间互不影响。所以这个区域不是线程共享的区域，我们称这类内存区域为“线程私有“区域。

​	如果一个线程正在执行的指令是Native方法，那么这是计数器的值为空（Undefined）。程序计数器是为执行Java字节码服务的，而本地方法都是由C等其他语言实现的，在执行本地方法时，大多都会直接映射到其原生平台上去执行，没有JVM什么事。

​	此内存区域是唯一一个Java虚拟机规范中没有规定任何OutOfMemoryError的区域。

###2.1.2 Java虚拟机栈

​	与程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期与线程相同。

​	Java虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时，都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程，就对应着一个栈帧从入栈到出栈的过程。

​	通常我们将Java内存模型分为堆和栈两部分，这是一种比较粗糙的分法，但是这两块内存区域确实是我们最关注的区域。而我们通常说的栈内存就是指的Java虚拟机栈或者说Java虚拟机栈的局部变量表部分。

####1.局部变量表

​	局部变量表中存放了编译器可知的各种基本数据类型、对象引用和returnAddress（指向一条字节码指令的地址）。returnAddress类型（返回地址类型），并不是Java语言API的一部分，会被Java虚拟机的jsr、ret和jsr_w指令所使用，并不会被程序员直接使用。returnAddress类型在Java语言之中并不存在相应的类型，也无法在程序运行期间更改returnAddress类型的值。

​	局部变量表是一组局部变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java文件编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。

​	其中64位长度的double和long类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用一个。局部变量表所需要的空间在编译期间完成分配，在运行期间不会再改变局部变量表的大小。

####2.操作数栈

​	操作数栈也常被称为操作栈，它是一个后入先出栈。JVM底层字节码指令集是基于栈类型的，所有的操作码都是对操作数栈上的数据进行操作，对于每一个方法的调用，JVM会建立一个操作数栈，以供计算使用。和局部变量一样，操作数栈的最大深度也是编译的时候写入到方法表的code属性的max_stacks数据项中。

​	操作数栈的每一个元素可以是任意的Java数据类型，包括long、double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。栈容量的单位为“字宽”，对于32位虚拟机来说，一个“字宽”占4个字节，64位虚拟机来说，一个“字宽”占8个字节。

​	当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作。例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。

​	另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了。

####3.动态链接

​	 每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。

​	编译是将将预处理生成的文件，经过词法分析、语法分析、语义分析以及优化后编译成若干个目标模块。可以理解为将高级语言翻译为计算机可以理解的二进制代码，即机器语言。链接是将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的载入模型。链接主要解决模块间的相互引用问题。链接一般分为静态链接、载入时动态链接以及运行时动态链接三种。

####4.方法出口

​	当一个方法被执行后，有两种方式退出这个方法。

​	第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口(Normal Method Invocation Completion)。

​	另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口(Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。

​	无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。

​	方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用都栈帧的操作数栈中，调用PC计数器的值以指向方法调用指令后面的一条指令等。

####5.附加信息

​	虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。

####6.异常

​	在Java虚拟机栈这个区域，Java虚拟机规范规定了两种异常状况。

​	如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverflowError异常。

​	如果虚拟机栈可以动态扩展（当前大部分虚拟机都可以动态扩展，但是Java虚拟机规范允许固定长度的虚拟机栈），在扩展时无法申请到足够的内存，会抛出OutOfMemoryError异常。

###2.1.3 本地方法栈	

​	与Java虚拟机栈作用相似，Java虚拟机栈是为了Java虚拟机执行Java方法（也就是字节码）服务，而本地方法栈是为Java虚拟机执行Native方法服务。

​	在Java虚拟机规范中，并没有对本地方法栈中方法使用的语言、使用方式以及数据结构的强制规范，所以允许虚拟机自由实现它。在HotSpot虚拟机中，将虚拟机栈和本地方法栈合二为一。

​	在本地方法栈中，也会抛出StackOverflowError和OutOfMemoryError。

###2.1.4 Java堆

​	对于大多数应用来说，Java堆是Java虚拟机所管理内存区域内最大的一块。Java堆是被所有线程共享的一块区域，在虚拟机启动的时候创建。Java堆内存唯一的目的就是用来存放对象实例，几乎所有的对象实例都是在Java堆中分配内存。在Java虚拟机规范中描述是：所有的对象实例以及数组都要在堆上分配。但是随着JIT编译器的发展与逃逸技术的逐渐成熟，栈上分配、标量替换优化技术将导致所有对象都在堆上分配不再绝对。

​	Java堆是垃圾收集器管理的主要区域，因此也被称为”GC堆“。

​	从内存回收的角度来看，由于现在垃圾收集器基本都采用分代收集算法，所依堆还可以细分为新生代和老年代。再细致一点有Eden空间、From Survivor空间、To Survivor空间等。

​	从内存分配的角度来看，Java堆中还能划分出多个线程私有的分配缓冲区。

​	无论怎么划分，本质上Java堆还是存储的对象实例，划分的目的是为了更好的回收内存或者更快的分配内存。

​	Java虚拟机规范中规定，Java堆可以处在物理上不连续的内存空间中，只需要逻辑上是连续的即可。既可以实现为固定大小，也可以是可扩展的（主流的虚拟机都是可扩展的）。

​	如果堆中没有内存再分配给对象实例，且堆无法继续扩展，将会抛出OutOfMemoryError异常。

### 2.1.5 方法区

​	方法区和Java堆一样，也是线程共享的一块内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

​	在Java虚拟机规范中，方法区被描述为Java堆的一个逻辑部分，但是它有一个别名叫作Non-Heap（非堆）。

​	对于HotSpot虚拟机开发而言，方法区经常被称为永久代。这仅仅是因为HotSpot虚拟机将GC分代收集扩展到了方法区，或者说用永久代来实现方法区，这样HotSpot的垃圾收集器可以像管理Java堆一样来管理方法区，省去了专门为方法区编写内存管理代码的工作。对于JRockit、J9等其他虚拟机而言，并不存在永久代这个概念。

​	原则上，如何实现方法区属于虚拟机实现细节，并不受虚拟机规范约束，但是使用永久代来实现方法区并不是个好主意，这样更容易出现内存溢出。因为永久代有-XX:MaxPermSize上限限制内存大小，而其他虚拟机只要没有碰到进程可用内存上限，就可以继续给方法区分配内存。HotSpot也有计划放弃永久代，改为采用Native Memory来实现方法区。在JDK 1.7中，已经把原来放在永久代中的字符串常量池移出，移到了堆中。

​	与Java堆一样，Java虚拟机规范对方法区的规定非常宽松，如不需要物理连续的内存空间，可以固定内存大小也可以可扩展，甚至还可以选择不实现垃圾收集。垃圾回收行为在这个区域较少出现，但是也并不是真如永久代的名字一样永久，在这个区域垃圾回收的主要目标是针对常量池的回收以及对类型的卸载。当时一般来说，对这个区域的垃圾回收比较难以令人满意，尤其是类型卸载，条件相当苛刻，当时这个区域的垃圾回收是相当有必要的。Sun公司的BUG列表中出现过多个严重BUG就是因为对这个区域的内存回收不完全导致的内存溢出。

​	Java虚拟机规范规定，方法区无法满足内存分配需求时，抛出OutOfMemoryError异常。

### 2.1.6 运行时常量池

​	方法区的一部分。Class文件中出了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池中存放。

​	Java虚拟机对Class文件的每一个部分都有严格的规定，每个字节用来存储那种数据都必须严格符合规范上的要求才能被虚拟机认可，装载并执行。但是虚拟机规范并没有对运行时常量池作出任何细节上的要求，由各个虚拟机自由实现，但是一般而言，运行时常量池出了保存class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。

​	 Java中的符号引用，编译时并不知道引用的地址，而是只有符号。只有在运行时才能把各个符号引用翻译为直接引用。直接引用和虚拟机的具体实现有关，可以是直接指向目标的指针、相对偏移量、一个间接定位到对象的句柄。

​	相对于Class文件的常量池，运行时常量池具备一个重要特征就是动态性。在Java语言中，常量并不要求在编译期间产生，也就是说并只有Class文件常量池中的内容才能进入运行时常量池，程序运行过程中也可能有新的常量被放入池中。用的较多的就是String类的intern()方法。

​	既然是方法区的一部分，那么运行时常量池在无法继续分配内存时，也会抛出OutOfMemoryError异常。

###2.1.7 直接内存

​	直接内存并不是虚拟机运行时内存的一部分，也不是Java虚拟机规范中定义的内存区域，但是它也被经常使用，也可能导致OutOfMemoryError异常。

​	在JDK 1.4中加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式。它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆内的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提升性能，因为避免了在Java堆和Native堆中来回复制数据。

​	直接分配本机内存不会受到Java堆大小的限制，但是只要是内存，就要受到机器总内存的限制。在配置虚拟机内存时，会根据实际内存设置-Xmx等参数，但是忽略了直接内存，使得各个内存区域的总和大于物理内存限制导致OutOfMemoryError异常。

##2.2 Java虚拟机中的对象

###2.2.1 对象的创建

​	在Java中有五种创建对象的方式。

| 方式                           | 是否调用构造方法 |
| ---------------------------- | -------- |
| 使用new关键字                     | 是        |
| 使用Class类的newInstance方法       | 是        |
| 使用Constructor类的newInstance方法 | 是        |
| 使用clone方法                    | 否        |
| 使用反序列化                       | 否        |

当虚拟机遇到一条new指令时的执行步骤：

####1. 类加载检查

首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否被加载、解析和初始化过。如果没有，那么要先执行类加载过程。

#### 2.分配内存

1.分配方式

通过类加载检查后，虚拟机将会给新对象分配内存。新对象所需的内存空间大小在类加载完成后就可以完全确定。分配内存空间的过程相当于从Java堆中把一块确定大小的内存划分出来。有两种分配方式：

（1）指针碰撞

如果Java堆中的内存是绝对规整的，即所有内存空间都是连续的，被用过的放在一边，空闲内存放在另一边，中间放着一个指针作为分界点的指示器。那么仅仅需要将指针那空闲内存一侧移动对象大小的距离。

（2）空闲列表

如果Java堆中的内存不是规整的，已用内存与空闲内存相互交错，虚拟机就必须维护一个列表，记录哪些内存块是可用的。分配的时候从列表中找出一块足够大的空间划分给对象，并更新列表。

采用什么方式分配内存由内存空间是否规整决定，而内存空间是否规整又是由垃圾收集器是否带有压缩整理功能决定。因此采用Serial、ParNew等带有Compact过程的垃圾收集器时，内存分配的算法是指针碰撞；而使用CMS这种基于Mark-Sweep算法的垃圾收集器时，通常采用的是空闲列表。

2.线程安全

内存分配过程中，还会遇到一个线程安全问题，例如同时给对象A和对象B分配内存，对象A分配了内存指针还没有来得及修改，对象B又同时使用了原来位置的指针来分配内存。为了解决这个问题，有两种方案。

（1）同步

对分配内存过程进行同步处理。虚拟机采用CAS配上失败重试的方法保证更新操作的原子性。

（2）线程分配缓冲

给每个线程在Java堆中预先分配一小块内存区域，称为本地线程分配缓冲。线程需要分配内存，就在该线程的缓冲区分配，直到这个区域使用完，才需要同步锁定，再次分配给该线程分配一个缓冲区。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB来设置。

####3.内存空间初始化

内存分配完成后，虚拟机需要将分配到的区域都初始化为零值（不包括对象头），如果采用了TLAB，这个步骤也可以提前到TLAB分配时。这步操作保证了对象的实例字段在Java代码中不赋初始值就能直接使用。

####4.对象头信息设置

初始化完成后，虚拟机要对对象进行必要的设置，例如对象是哪个类的实例、如何才能找到类的元数据、对象的哈希码、对象的GC分代年龄等信息等，这些信息存放在对象的对象头中。

####5.对象初始化

完成上述步骤，从虚拟机的视角来看，一个新对象已经产生了，而从Java程序的视角来看，对象创建才刚刚开始，初始化方法还没执行。所以执行new指令后，还会执行初始化方法，按照程序员的意愿对对象进行初始化，这样对象才能被使用。

### 2.2.2 对象的内存布局

对象的内存大致可以分为三个区域：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。

#### 1.对象头

对象头包括两个部分。

（1）Mark Word

​	第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据长度在32位虚拟机和64位虚拟机（未开启压缩指针）中分别是32bit和64bit，官方称为“Mark Word“。

​	实际上，对象需要存储的运行时数据已经超出了32bit、64bit结构所能记录的限度。由于这一部分是与对象自身定义数据无关的额外存储成本，出于空间利用效率考虑，这部分被设计成了一个非固定的数据结构以便在极小的空间内存储尽可能多的信息，他会根据对象的状态复用自己的存储空间。HotSpot虚拟机对象头的MarkWord见下表：

| 存储内容                | 标志位  | 状态        |
| ------------------- | ---- | --------- |
| 对象哈希码、对象分代年龄        | 01   | 未锁定       |
| 指向锁定记录的指针           | 00   | 轻量级锁定     |
| 指向重量级锁的指针           | 10   | 膨胀（重量级锁定） |
| 空，不需要记录信息           | 11   | GC标记      |
| 偏向线程ID、偏向时间戳、对象分代年龄 | 01   | 可偏向       |

（2）类型指针

​	对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。并不是所有虚拟机实现都必须在对象数据上保留类型指针，查找对象的元数据并不一定要经过对象本身。

（3）数组

​	如果对象是一个Java数组，那么对象头中还必须有一块用于记录数组长度的数据，因为Java虚拟机可以通过对象的元数据信息确定普通Java对象的大小，但是无法从数据的元数据确定数组的大小。

#### 2.实例数据

​	实例数据部分是真正存储有效信息的部分，也就是在程序代码中定义的各种类型的字段内容。无论是从父类继承来的还是在类中定义的都需要在这部分记录下来。

​	这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略是longs/doubles、ints、shorts\chars、bytes\booleans、oops（Ordinary Object Pointers），从分配策略可以看出，相同宽度的字段总是分配到一起。在满足这个条件的情况下，父类中定义的变量会出现在子类之前。此外CompactFields参数设置为true（默认为true），那么子类中较窄的变量也可能会插入到父类变量的空隙中。

####3.对齐填充

第三部分对齐填充并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用。HotSpot虚拟机自动内存管理系统要求对象的起始地址必须是8字节的整数倍。所以当对象的长度没有对齐的时候，就需要对齐填充来补全。

### 2.2.3 对象访问定位

​	在Java程序中，需要通过栈上的reference数据来操作堆上的具体对象。但是在Java虚拟机规范中只规定了reference类型是一个指向对象的引用，并没有定义这个引用通过何种方式对定位、访问堆中对象的具体位置，所以对象访问方式也是取决于虚拟机的具体实现。目前，主流的访问方式有使用句柄和直接指针两种。

####1.两种定位、访问方式

（1）使用句柄

使用句柄，会在Java堆中划出一块内存用来作为句柄池，reference中存储的就是对象的句柄地址，而句柄包含了对象实例数据与类型数据各自的具体地址信息。

![java虚拟机图片3](/java虚拟机图片3.jpg)

（2）直接指针

如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的就直接是对象的地址。

![java虚拟机图片4](/java虚拟机图片4.jpg)

#### 2.两种方式各自的优势

​	使用句柄来访问对象最大的好处就是reference中储存的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。在垃圾收集时移动对象是非常普遍的行为。

​	直接指针方式的最大好处就是速度快，相比于句柄方式少了一次指针定位的时间开销。由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项非常可观的执行成本。

#### 3.HotSpot的对象访问方式

​	就HotSpot而言，使用的是直接指针方式进行对象访问，但是对于整个软件开发范围来看，各种语言和框架使用句柄来访问的情况也非常常见。

## 2.3 OutOfMemoryError异常

​	在Java虚拟机中，除了程序计数器外，其他所有的内存区域都可能会出现OOM异常。

### 2.3.1 Java堆溢出

​	可以通过设置参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常是Dump出当前的内存堆转储快照以便事后进行分析。

​	Java堆内存的OOM异常是最常见的一种内存溢出情况。当出现异常时会进一步跟着“Java heap space”提示是堆内存出现内存溢出。

​	解决这个区域的异常，一般是先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出的堆转储快照进行分析，重点是确认内存中的对象是否是必需的，也就是说先分清楚是出现了内存泄漏还是内存溢出。

​	如果是内存泄漏，可以进一步通过工具查看泄漏对象到GC Roots的引用链。通过引用链就能找出垃圾收集器无法回收的原因，也就便于准确地定位出泄露代码的位置。

​	如果不是内存泄漏，那么内存中的对象都还必须或者，那就应当检查虚拟机的堆参数（-Xmx与-Xms），看是否能够调大。从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期间的内存消耗。

### 2.3.2 虚拟机栈和本地方法栈溢出

​	对于HotSpot来说，不区分虚拟机栈和本地方法栈，栈容量通过-Xss参数来调节。

​	虽然虚拟机规范中规定了OutOfMemoryError与StackOverflowError两种异常，但实际实验表明，单线程下，无论是栈深度大于虚拟机允许的最大深度还是虚拟机扩展栈空间时无法申请到足够的空间，都只会抛出StackOverflowError异常。

​	多线程的情况下，通过增加线程可能出现OutOfMemoryError异常。在不能减少线程数或加大物理内存的情况下，只能通过减少最大堆和减少栈容量的换取更多的线程。

### 2.3.3 方法区和运行时常量池溢出

​	当前很多主流框架，如Spring、Hibernate，在对类进行增强时，都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的class可以加载入内存。

​	方法区溢出也是一种常见的内存溢出，尤其在经常动态生成大量Class的应用中。因为一个类要被回收，判定的条件较为苛刻。

​	容易出现方法区溢出的程序包括：

​	1.使用了CGLib字节码技术

​	2.动态语言应用

​	3.大量JSP或动态生成JSP文件的应用（JSP第一次运行也会被编译为Java类）

​	4.易于OSGi的应用

### 2.3.4 本机直接内存溢出

​	DirectMemory容量可以通过-XX：MaxDirectMemorySize指定。如果不指定默认与Java堆的最大值一样。

​	DirectMemory的内存溢出，一个明显的特征是在Heap Dump文件中不会看到明显的异常。如果发现OOM之后的Dump文件很小，而程序中又直接或间接使用了NIO，那就要考虑是不是直接内存溢出了。

# 第三章 垃圾收集器与内存分配策略

## 3.1 概述

### 1.GC所要关注的问题

- 哪些内存需要回收
- 什么时候回收
- 如何回收

### 2.为什么要了解GC和内存分配

目前，内存的动态分配与内存回收技术已经相当成熟，一切看似都进入了“自动化”的时代。我们了解GC和内存分配的目的在于，当出现内存泄漏、内存溢出等问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们需要对这些“自动化”技术实施必要的监控和调节。

##3.2 哪些内存需要回收

### 3.2.1 对象

​	垃圾回收工作的主要区域是Java堆，而堆的唯一目的就是存储对象。垃圾收集器在对堆进行回收之前，首先要进行的是确定哪些对象可以被回收。两种算法：引用计数算法和可达性分析算法。

####1.判断是否回收

#####1.1 引用计数算法

​	在堆中存储对象时，在对象头处维护一个counter计数器，如果一个对象增加了一个引用与之相连，则将counter++。如果一个引用关系失效则counter–。如果一个对象的counter变为0，则说明该对象已经被废弃，不处于存活状态。

​	引用计数算法实现简单，判定效率也很高，在大多数情况下这是一个不错的算法。但是，主流的Java虚拟机里面都没有选用引用计数算法来管理内存。原因如下：

​	1.相互循环引用无法回收

​	其中最主要的原因是它很难解决对象之间相互循环引用的问题。

​	例如，对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。

​	2.多类型引用

​	 jdk从1.2开始增加了多种引用方式：软引用、弱引用、虚引用，且在不同引用情况下程序应进行不同的操作。如果我们只采用一个引用计数法来计数无法准确的区分这么多种引用的情况。

​	引用计数法无法解决多种类型引用的问题。但这并不是致命的，因为我们可以通过增加逻辑区分四种引用情况，虽然麻烦一些但还算是引用计数法的变体，真正让引用计数法彻底报废的还是因为循环引用问题。

#####1.2 可达性分析算法

​	在主流的商用程序语言中(Java和C#)，都是使用可达性分析算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

![java虚拟机图片5](/java虚拟机图片5.jpg)

​	如上图中，Object1、2、3是存活对象，而Object4、5、6虽然还有别的对象持有引用，但是由于没有引用链到达GC Roots对象，所以是可回收对象。

​	可以作为GC Roots的对象：

1. 虚拟机栈(栈桢中的本地变量表)中的引用的对象
2. 方法区中的类静态属性引用的对象
3. 方法区中的常量引用的对象
4. 本地方法栈中JNI（Native方法）的引用的对象

#####1.3 引用

​	无论是使用引用计数算法还是可达性分析算法，判定对象是否存活都与对象的引用密切相关。

​	在JDK1.2以前，Java对引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。

​	这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。

​	在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。从而使程序能更加灵活地控制对象的生命周期。

​	1.强引用就是指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 

```java
String str = new String("强引用");//str就是一个强引用，也是我们平时使用最多，存在最普遍的一类引用
```

​	2.软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。

```java
// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，
// 这里的软引用指的是指向new String("str")的引用，也就是SoftReference类中T
// 软引用所指向的对象在内存不足的时候会被回收
SoftReference<String> wrf = new SoftReference<String>(new String("str"));
```

​	使用场景：创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。PS：图片编辑器，视频编辑器之类的软件可以使用这种思路。

​	比如考虑一个图像编辑器的程序。该程序会把图像文件的全部内容都读取到内存中，以方便进行处理。而用户也可以同时打开多个文件。当同时打开的文件过多的时候，就可能造成内存不足。如果使用软引用来指向图像文件内容的话，垃圾回收器就可以在必要的时候回收掉这些内存。

```java
public class ImageData {
    private String path;
    private SoftReference<byte[]> dataRef;
    public ImageData(String path) {
        this.path = path;
        dataRef = new SoftReference<byte[]>(new byte[0]);
    }
    private byte[] readImage() {
        return new byte[1024 * 1024]; //省略了读取文件的操作
    }
    public byte[] getData() {
        byte[] dataArray = dataRef.get();
        if (dataArray == null || dataArray.length == 0) {
            dataArray = readImage();
            dataRef = new SoftReference<byte[]>(dataArray);
        }
        return dataArray;
    }
}
```

​	3.弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。

​	它的作用是引用一个对象，但是并不阻止该对象被回收。在垃圾回收器运行的时候，如果一个对象的所有引用都是弱引用的话，该对象会被回收。弱引用的作用在于解决强引用所带来的对象之间在存活时间上的耦合关系。弱引用最常见的用处是在集合类中，尤其在哈希表中。哈希表的接口允许使用任何Java对象作为键来使用。当一个键值对被放入到哈希表中之后，哈希表对象本身就有了对这些键和值对象的引用。如果这种引用是强引用的话，那么只要哈希表对象本身还存活，其中所包含的键和值对象是不会被回收的。如果某个存活时间很长的哈希表中包含的键值对很多，最终就有可能消耗掉JVM中全部的内存。对于这种情况的解决办法就是使用弱引用来引用这些对象，这样哈希表中的键和值对象都能被垃圾回收。Java中提供了WeakHashMap来满足这一常见需求。

```java
WeakReference<String> wrf = new WeakReference<String>(new String("str"));
```

​	4.虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。

​	对象终止机制：在Object类里面有个finalize方法，其设计的初衷是在一个对象被真正回收之前，可以用来执行一些清理的工作。因为Java并没有提供类似C++的析构函数一样的机制，就通过 finalize方法来实现。但是问题在于垃圾回收器的运行时间是不固定的，所以这些清理工作的实际运行时间也是不能预知的。

​	幽灵引用（phantom reference）可以解决这个问题。在创建幽灵引用PhantomReference的时候必须要指定一个引用队列。当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了。

​	幽灵引用及其队列的使用情况并不多见，主要用来实现比较精细的内存使用控制，这对于移动设备来说是很有意义的。程序可以在确定一个对象要被回收之后，再申请内存创建新的对象。通过这种方式可以使得程序所消耗的内存维持在一个相对较低的数量。比如下面的代码给出了一个缓冲区的实现示例。

```java
public class PhantomBuffer {
  private byte[] data = new byte[0];
    private ReferenceQueue<byte[]> queue = new ReferenceQueue<byte[]>();
    private PhantomReference<byte[]> ref = new PhantomReference<byte[]>(data, queue);
    public byte[] get(int size) {
        if (size <= 0) {
            throw new IllegalArgumentException("Wrong buffer size");
        }
        if (data.length < size) {
            data = null;
            System.gc(); //强制运行垃圾回收器
             try {
                queue.remove(); //该方法会阻塞直到队列非空
                ref.clear(); //幽灵引用不会自动清空，要手动运行
                ref = null;
                data = new byte[size];
                ref = new PhantomReference<byte[]>(data, queue);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
       }
       return data;
    }
}
```

​	在上面的代码中，每次申请新的缓冲区的时候，都首先确保之前的缓冲区的字节数组已经被成功回收。引用队列的remove方法会阻塞直到新的幽灵引用被加入到队列中。不过需要注意的是，这种做法会导致垃圾回收器被运行的次数过多，可能会造成程序的吞吐量过低。

​	

​	引用队列：在有些情况下，程序会需要在一个对象的可达到性发生变化的时候得到通知。比如某个对象的强引用都已经不存在了，只剩下软引用或是弱引用。但是还需要对引用本身做一些的处理。典型的情景是在哈希表中。引用对象是作为WeakHashMap中的键对象的，当其引用的实际对象被垃圾回收之后，就需要把该键值对从哈希表中删除。有了引用队列（ReferenceQueue），就可以方便的获取到这些弱引用对象，将它们从表中删除。在软引用和弱引用对象被添加到队列之前，其对实际对象的引用会被自动清空。通过引用队列的poll/remove方法就可以分别以非阻塞和阻塞的方式获取队列中的引用对象。

####2.finalize方法

​	即使在可达性分析中的不可达对象，也不是“非死不可”，而只是进入了缓刑阶段。在对象真正死亡，被回收之前需要经历至少两次标记：

​	1.标记不可达对象

​	首先在可达性分析后，如果对象没有与GC Roots对象相关联的引用链，那么它将会被第一次标记并进行一次筛选。

​	2.判断是否有必要执行finalize方法

​	筛选的条件是该对象是否有必要执行finalize方法。如果对象没有覆盖finalize方法或者finalize方法已经被虚拟机执行过一次了，那么虚拟机会视为没有必要执行。

​	3.执行finalize方法

​	如果判定为有必要执行finalize方法，那么这个对象就会被放置到一个叫F-Queue的队列中，稍后虚拟机会自动建立一个低优先级的Finalizer线程去执行它。这里的“执行”是指虚拟机会触发这个方法，但是不承诺会等待他执行结束。原因是如果一个对象的finalize方法执行缓慢，或者发生死循环，将可能导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。

​	finalize方法是对象逃脱死亡命运的最后一次机会，如果对象在finalize方法中拯救了自己（重新与引用链上的任意一个对象关联），那么GC第二次对F-Queue队列中对象标记时，会将这部分对象移出“即将回收”集合。这时仍被标记的对象，基本上就真的被回收了。

​	对任何一个对象的finalize方法都只会被系统自动调用一次，如果下一次对象面临回收，它的finalize方法不会被再次执行。

​	另外，并不鼓励使用finalize方法来拯救对象，而是尽量避免使用它。他不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时。可以完全忘记Java中有finalize方法的存在。

###3.2.2 方法区

​	很多人认为方法区（HotSpot中的永久代）是没有垃圾收集的，Java虚拟机规范中也说过不要求虚拟机在方法区实现垃圾收集。在方法区中的垃圾收集性价比较低。在堆中，尤其是新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而方法区的垃圾收集效率远低于此。

​	方法区的垃圾收集主要是回收废弃常量和无用的类两部分内容。

​	1.回收废弃常量

​	回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。

​	2.回收无用的类

​	回收废弃常量的判定条件比较简单，但是判定无用的类就相对复杂，需要满足以下三个条件才能算是“无用的类”：

​	（1）该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。

​	（2）加载该类的ClassLoader已经被回收。	

​	（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

​	虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose：class以及-XX：+TraceClassLoading、-XX：+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。

​	在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。



##3.3 垃圾收集算法

###3.3.1 标记-清除算法

​	标记-清除算法是最基础的垃圾收集算法，算法分为两个阶段：标记和清除。首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。后续的收集算法都是基于这种思路并对其不足进行改进而得到的。

​	它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

![java虚拟机图片6](/java虚拟机图片6.jpg)

###3.3.2 复制算法

​	为了解决效率问题，出现了一种称为“复制”的算法，他将内存空间分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的这一块内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。

![java虚拟机图片7](/java虚拟机图片7.jpg)

​	现代的商业虚拟机都采用复制算法来回收新生代。IBM公司的研究表明，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间。每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上最后清理掉Eden和刚才用过的Survivor空间。

​	HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。

​	由于在98%的情况下都能正常运行，分配担保只是为了应对少数出现的另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象的情况。这些对象将直接通过分配担保机制进入老年代。

###3.3.3 标记-整理算法

​	复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

​	根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

![java虚拟机图片8](/java虚拟机图片8.jpg)

###3.3.4 分代收集算法

​	当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

​	在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。



##3.4 HotSpot中的算法实现

###3.4.1 枚举根节点

​	要进行可达性分析，首先要找到GC Roots对象。现在很多应用仅方法区就有几百兆，要逐个检查里面的所有引用，是一个非常耗时的操作。

​	另外，在进行可达性分析的时候，必须要确保在一个一致性的快照中进行（这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，否则就无法保证分析的准确性）。这点是导致在GC时必须停顿所有的Java执行线程（Sun将这件事情称为“Stop The World”）的其中一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。

​	在目前的主流Java虚拟机中，都是采用的准确式内存管理。所以在所有执行线程停顿下来枚举根节点的时候，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。

​	通过准确式内存管理（HotSpot中是使用一组称为OopMap的数据结构来实现的），减少了枚举根节点的耗时，所有执行线程停顿的时间变短，GC的效率更高。

###3.4.2 安全点

​	在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。	

​	实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。

​	Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。

​	对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。

​	抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。

​	而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。

###3.4.3 安全区域

​	使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。

​	安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。

​	在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。

##3.5 垃圾收集器

​	垃圾收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。对于垃圾收集器的实现Java虚拟机规范中并没有任何规定，因此不同厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大区别，并且一般都会提供参数供用户根据自己应用的特点和要求组合出各个年代所使用的收集器。

​	这里主要介绍JDK1.7 Update14之后的HotSpot的虚拟机，下图中存在连线的虚拟机可以搭配使用。

![java虚拟机图片9](/java虚拟机图片9.jpg)

​	各个垃圾收集器各有特点，并没有最好的垃圾收集器，更没有万能的垃圾收集器，我们只能根据需要去选择最适合的垃圾收集器。

###3.5.1 垃圾收集器名词说明

#### 1.并行（Parallel）

​	这里的并行指多条垃圾收集线程同时工作，但是此时用户线程仍然处于等待状态。

#### 2.并发（Concurrent）

​	这里的并发指用户线程与垃圾收集线程同时执行（但不一定是并发的，可能是交替执行），用户线程在继续运行，而垃圾收集程序运行于另一个CPU上。

#### 3.吞吐量（Throughput）

​	这里的吞吐量指CPU用于执行用户代码的时间与CPU总消耗时间的比值。即吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集时间）。	

###3.5.2 Serial收集器

​	Serial收集器是最基本、发展历史最悠久的收集器。在JDK1.3.1之前是虚拟机新生代收集的唯一选择。

	#### 1.特点-单线程

​	它是一个单线程的收集器，只使用一个CPU或一条收集线程去完成垃圾收集。更重要的是，它进行垃圾收集时，必须暂停其他所有的工作现场，直到它收集结束。

![java虚拟机图片10](/java虚拟机图片10.jpg)

​								Serial/Serial Old收集器运行示意图

####2.优点

​	在单线程或者说单CPU的环境中，它简单而高效，是虚拟机运行在Client模式下默认的新生代收集器。对于单CPU环境来说，Serial没有线程交互开销，专心做垃圾收集，从而获得最高的单线程收集效率。对于桌面应用来说，分配给虚拟机的内存不会太大，对于几十兆到几百兆的内存来说，停顿完全可以控制在几十毫秒到一百多毫秒，只要不是很频繁的进行垃圾收集，这个停顿完全可以接受。所以对于运行在Client模式下的虚拟机来说，Serial收集器是一个很好的选择。

### 3.5.3 ParNew收集器

​	ParNew收集器就是Serial收集器的一个多线程版本。

####1.特点1-多线程的Serial

​	除了多线程进行垃圾回收外，他的控制参数、收集算法、Stop The World、对象分配规则、回收策略等，都与Serial一致。实现上，这两种收集器共用了相当多的代码。

![java虚拟机图片11](/java虚拟机图片11.jpg)

​								ParNew/Serial Old收集器运行示意图

####2.特点2-除Serial外，只有它可以与CMS配合使用

​	ParNew是许多运行在Server模式下的虚拟机的首选新生代虚拟机，其中有一个与性能无关的原因是，除了Serial外，只有它可以与CMS搭配使用。如果使用CMS作为老年代收集器的话，就必须选择Serial或ParNew中的一个作为新生代收集器。使用-XX:+UseConcMarkSweepGC选项后的默认收集器就是ParNew。也可以使用-XX:+UseParNewGC来指定使用ParNew收集器。

####3.优点

​	在单CPU下，ParNew的效率不会比Serial高，甚至由于线程交互的开销，在双CPU下都不能百分之百的保证超过Serial。但是随着CPU数量的增加，它对于系统资源的有效利用还是能带来很多好处。它默认开启的线程数与CPU数量相同，在CPU非常多的情况下，可以通过-XX:ParallelGCThreads参数来限制垃圾收集器的线程数。

### 3.5.4 Parallel Scavenge收集器

​	Parallel Scavenge收集器是一个使用复制算法的多线程新生代收集器。

#### 1.特点-可控制吞吐量

​	其他收集器的关注点在于尽量缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的是达到一个可控制的吞吐量。由于与吞吐量关系密切，Parallel Scavenge收集器也经常称为“吞吐量优先”收集器。

​	停顿时间越短就越适合与用户交互的程序，良好的响应时间能够提升用户的体验。而高的吞吐量则可以保证CPU的高效率利用，尽快完成运算任何。主要适合在后台运算，没有太多交互任务的程序。

​	Parallel Scavenge收集器提供两个参数以精确控制吞吐量。

​	（1）-XX:MaxGCPauseMillis

​	用于控制最大的垃圾收集停顿时间，允许值是一个大于0的毫秒数，收集器将尽可能的保证不超过设定值。但是值越小并不意味着垃圾收集越快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的。

​	例如，把原来500MB的新生代减小为300MB，使收集更快。但是垃圾收集会发生的更频繁，原来10秒执行一次垃圾收集，一次持续100毫秒，现在5秒执行一次垃圾收集，一次执行70毫秒。停顿时间短了，但是吞吐量也下降了。

​	（2）-XX:GCTimeRatio

​	用于直接设置吞吐量大小 ，值是一个大于0且小于100的整数，用于表示垃圾收集时间所占的比率。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。

​	 即垃圾收集时间/总时间<=1/(1+n)。这个参数的默认值为99，就是允许最大1%（即1/（1+99））的垃圾收集
时间。

####2.特点-自适应调节

​	Parallel Scavenge收集器还有一个参数-XX：+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象年龄（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。

####3.优点

​	如果读者对于收集器运作原来不太了解，手工优化存在困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGCPauseMillis参数（更关注最大停顿时间）或GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。

​	自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。

###3.5.5 Serial Old收集器

​	Serial Old收集器是Serial收集器的老年代版本，同样是单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。

​	如果在在Server模式下使用，主要有两大用途：

​	1.在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用 。

​	2.作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。

![java虚拟机图片10](/java虚拟机图片10.jpg)

​								Serial/Serial Old收集器运行示意图

**说明**：Parallel Scavenge收集器架构中本身有PS MarkSweep收集器来进行老年代收集，并非直接使用了Serial Old收集器，但是这个PS MarkSweep收集器与Serial Old的实现非常接近，所以在官方的许多资料中都是直接以Serial Old代替PS MarkSweep进行讲解。

###3.5.6 Parallel Old收集器

​	Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择。

​	由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。

​	直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。

![java虚拟机图片12](/java虚拟机图片12.jpg)

​					Parallel Scavenge/Parallel Old收集器运行示意图

###3.5.7 CMS收集器

​	CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种集器来说更复杂一些，整个过程分为6个步骤：

####3.5.7.1 回收过程

​	1.初始标记（CMS initial mark）

​	在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The Word)。这个过程从垃圾回收的"根对象"开始，只扫描到能够和"根对象"直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。

​	2.并发标记（CMS concurrent mark）

​	这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。

​	3.并发预处清理（CMS concurrent preclean）

​	由于CMS的目的是为了获得最短停顿时间，而接下来的重新标记阶段要STW，所以这个阶段的目的就是做尽可能多的工作来减少重新标记阶段停顿的时间。此阶段标记从新生代晋升的对象、新分配到老年代的对象以及在并发阶段被修改了的对象。

​	在这个阶段要确保被标记的对象都是存活的，那么就需要全量的扫描新生代和老年代，而这个过程显然会很慢，所以就必须要有一个能够快速识别新生代和老年代对象活着的机制。

​	（1）新生代

​	首先，我们知道新生代进行一次垃圾回收之后能够存活下来的对象很少，那么在扫描新生代之前进行一次Minor GC（新生代垃圾回收），扫描新生代的工作量就会减少很多。

​	CMS提供了两个参数CMSScheduleRemarkEdenSizeThreshold和CMSScheduleRemarkEdenPenetration，默认值分别是2M和50%。两个参数组合起来意味着预清理后，eden空间使用超过2M时启动可中断的并发预清理（CMS-concurrent-abortable-preclean），直到eden空间使用率达到50%时中断，进入remark阶段。

​	如果在这个过程中进行了一次Minor GC，那么就万事大吉了。但是我们是不能保证一定会执行Minor GC的，垃圾回收是JVM自动调度的，我们不能一直等待虚拟机执行Minor GC，所以CMS提供了一个参数CMSMaxAbortablePrecleanTime，默认值为5S。只要到了5S，不管发没发生Minor GC，有没有到CMSScheduleRemardEdenPenetration都会中止此阶段，进入remark。如果这5S内没有执行Minor GC，CMS提供了CMSScavengeBeforeRemark参数，使remark前强制进行一次Minor GC。但是这样做的好处是执行过一次Minor GC后，remake阶段停顿较短。但是同样的Minor GC需要停顿，紧跟的remake阶段也需要停顿，所以停顿的时间依然较长。

​	预清理阶段会尽可能多做一些事情来减少remark停顿时间。remark的rescan阶段是多线程的，为了便于多线程扫描新生代，**预清理阶段会将新生代分块**。每个块中存放着多个对象，这样remark阶段就不需要从头开始识别每个对象的起始位置。多个线程的职责就很明确了，把分块分配给多个线程，很快就扫描完。遗憾的是，这种办法仍然是建立在发生了Minor GC的条件下。如果没有发生Minor GC，top（下一个可以分配的地址空间）以下的所有空间被认为是一个块(这个块包含了新生代大部分内容)。这种块对于remark阶段并不会起到多少作用，因此并行效率也会降低。

​	（2）老年代

​	老年代的机制与一个叫**CARD TABLE**的东西（这个东西其实就是个数组,数组中每个位置存的是一个byte）密不可分。

​	CMS将老年代的空间分成大小为512bytes的块，card table中的每个元素对应着一个块。

​	并发标记时，如果某个对象的引用发生了变化，就标记该对象所在的块为  **dirty card**。

​	并发预清理阶段就会重新扫描该块，将该对象引用的对象标识为可达。

​	举个例子：

​	并发标记时对象的状态：![CMS老年代回收机制-1](/CMS老年代回收机制-1.png)

​	随后current obj的引用发生了变化，current obj所在的块被标记为了dirty card。

​	![CMS老年代回收机制-2](/CMS老年代回收机制-2.png)

​	随后到了pre-cleaning阶段，会对这些在并发标记阶段被修改的对象进行重新标记，同时清除dirty card标志

​	![CMS老年代回收机制-3](/CMS老年代回收机制-3.png)

​	除了标记在并发标记过程中被修改的对象外，dirty Card还可以用来对老年代引用新生代进行标记（老年代引用新生代这种场景不足1%）。这样，在Minor GC过程中通过扫描dirty card就可以快速识别被老年代引用的新生代对象。

​	4.重新标记（CMS remark）

​	这个阶段会Stop The World，收集器线程扫描在CMS堆中剩余的对象。扫描从"根对象"开始向下追溯，并处理对象关联。由于有了前面做的大量的工作，所以这个过程中停顿的时间也会减少。注意，这个过程是多线程的。

​	5.并发清理（Concurrent sweeping）

​	这个阶段会清理那些无效的对象。这个过程中用户线程会被激活，用户线程和GC线程是并发执行的。

​	6.并发重置（Concurrent reset）	

​	这个阶段并发执行，重新设置CMS算法内部的数据结构，准备下一个CMS生命周期的使用。

![CMS收集器运行示意图](/CMS收集器运行示意图.png)

#### 3.5.7.2 缺点

​	CMS是一款优秀的垃圾收集器，优点在于并发收集、低停顿。在Sun公司的一些官方文档中也被称为并发低停顿收集器。但是CMS还远远达不到完美的程度，还有很多缺点。

​	1.消耗较多的CPU资源

​	虽然CMS将大量的工作放在并发阶段执行，尽可能的减少STW的时间，但是并发阶段依然会占用一部分CPU资源导致程序变慢，程序的总吞吐量变低。

​	CMS默认的线程数是(CPU数量+3)/4，也就是当CPU在4个以上时，垃圾收集线程至少会占用25%以上的CPU资源。但是如果CPU数量少于4个，那么垃圾收集线程对资源的占用就会对用户线程造成很大的影响。虚拟机提供了一种“增量式并发收集器”（i-CMS，CMS收集器的变种），通过垃圾收集线程和用户线程交替执行来实现并发。虽然这样会减少垃圾收集线程占用CPU资源对用户线程的影响，但是会导致垃圾收集时间变长，i-CMS的效果一般，不提倡使用。但是现在的服务器几乎不会出现CPU少于4个的情况。

​	2.无法处理浮动垃圾

​	有CMS并发清理阶段是和用户线程并发执行的，这时候程序也会不断产生新的垃圾，而这部分新的垃圾是标记阶段之后产生的，CMS不能在本次收集中处理他们，需要到下一次GC才能处理，这部分垃圾称为浮动垃圾（Floating Garbage）。

​	由于清理过程和用户线程是并发执行的，所以不能等到老年代全部使用了再开始垃圾回收，要预留一部分内存给并发清理阶段的用户线程使用。在JDK1.5时，当老年代使用了68%就会激活GC，这是一个相对保守的设置。如果老年代增长不是太快，可以通过CMSInitiatingOccupancyFraction参数调高触发百分比，以便降低内存回收次数从而提高程序运行效率。在JDK1.6中，这个值已经被提高到了92%。

​	虽然调高触发的百分比可以减少内存收集次数，提升程序性能，但是如果预留的这部分内存无法满足CMS运行期间的程序需求，就会出现Concurrent  Mode Failure错误。这时虚拟机就会启动后备方案：临时启用Serial Old收集器对老年代进行回收，这样就会停顿很长时间。所以CMSInitiatingOccupancyFraction的值需要根据实际情况分析确定，如果设置的太高会导致频繁出现Concurrent  Mode Failure导致性能降低。

​	其实CMS有动态检查机制，CMS会根据历史记录，预测老年代还需要多久填满及进行一次回收所需要的时间。在老年代空间用完之前，CMS可以根据自己的预测自动执行垃圾回收。这个特性可以使用参数UseCMSInitiatingOccupancyOnly来关闭。

​	3.内存碎片

​	CMS是基于“标记-清除”算法的，这意味着收集结束会产生大量的内存碎片。如果空间碎片过多，在对象分配的时候，就会出现即使还有大量的内存空间，但是找不出一个连续的空间来分配给当前对象。这样虚拟机就会触发一次Full GC。

​	CMS的解决方案是使用UseCMSCompactAtFullCollection参数(默认开启)，在顶不住要进行Full GC时开启内存碎片整理。这个过程需要STW，碎片问题解决了,但停顿时间又变长了。

​	虚拟机还提供了另外一个参数CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认为0，每次进入Full GC时都进行碎片整理）。

### 3.5.8 G1收集器

​	G1（Garbage-Frist）收集器是一款面向服务器端应用的垃圾收集器。HotSpot团队的预期是在未来用G1替换掉CMS收集器。

#### 3.5.8.1 特点

​	1.并行与并发

​	G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。

​	2.分代收集

​	与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆（既能处理新生代又能处理老年代），但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。

​	3.空间整合

​	与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。

​	4.可预测的停顿

​	这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

#### 3.5.8.2 Region

​	在G1之前的收集器进行收集的范围都是整个新生代或者老年代。而使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。

​	G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

#### 3.5.8.3 Remembered Set

​	各个Region都可不能是独立存在的，各Region中对象可能存在引用关系，那么在可达性分析的时候，岂不是要扫描整个Java堆内存？不只是在G1中存在这样的问题，其实在分代收集中，也会出现类似的问题，只是G1的问题更为突出。新生代对象的收集很频繁，但是新生代的规模一般都比老年代小很多，如果每次收集新生代都要去扫描老年代，那么Minor GC的效率会降低很多。

​	对于G1或者其他分代收集器，虚拟机都是采用Remembered Set来避免全堆扫描。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。

#### 3.5.8.4 收集步骤

​	如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：

- 初始标记（Initial Marking）
- 并发标记（Concurrent Marking）
- 最终标记（Final Marking）
- 筛选回收（Live Data Counting and Evacuation）



​	1.初始标记

​	初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。

​	2.并发标记

​	并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。

​	3.最终标记

​	而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。

​	4.筛选回收

​	筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，从Sun公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。

![G1收集器运行示意图](/G1收集器运行示意图.jpg)

### 3.5.9 理解GC日志

​	每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定的共性，例如以下两段典型的GC日志：

```text
	33.125：[GC[DefNew：3324K-＞152K（3712K），0.0025925 secs]3324K-＞152K（11904K），0.0031680 secs]
	1 0 0.6 6 7：[F u l l G C[T e n u r e d：0 K-＞2 1 0 K（1 0 2 4 0 K），0.0 1 4 9 1 4 2 s e c s]4603K-＞210K（19456K），[Perm：2999K-＞2999K（21248K）]，0.0150007 secs][Times：user=0.01 sys=0.00，real=0.02 secs]
```

​	最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。

​	GC日志开头的“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现“[Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc（）方法所触发的收集，那么在这里将显示“[Full GC（System）”。

```text
[Full GC 283.736：[ParNew：261599K-＞261599K（261952K），0.0000288 secs]
```

​	接下来的“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的，例如上面样例所使用的Serial收集器中的新生代名为“DefaultNew Generation”，所以显示的是“[DefNew”。如果是ParNew收集器，新生代名称就会变为“[ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。

​	后面方括号内部的“3324K-＞152K（3712K）”含义是“GC前该内存区域已使用容量-＞GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“3324K-＞152K（11904K）”表示“GC前Java堆已使用容量-＞GC后Java堆已使用容量（Java堆总容量）”。

​	再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“[Times：user=0.01 sys=0.00，real=0.02 secs]”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以读者看到user或sys时间超过real时间是完全正常的。

### 3.5.10 垃圾收集器参数总结

| 参数                             | 描述                                       |
| ------------------------------ | ---------------------------------------- |
| UseSerialGC                    | 虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收 |
| UseParNewGC                    | 打开此开关后，使用ParNew+Serial Old的收集器组合进行内存回收   |
| UseConcMarkSweepGC             | 打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用 |
| UseParallelGC                  | 虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old（PS MarkSweep）的收集器组合进行内存回收 |
| UseParallelOldGC               | 打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行内存回收 |
| SurvivorRatio                  | 新生代中Eden区域与Survivor区域的容量比值，默认值为8，代表Eden：Survivor=8：1 |
| PretenureSizeThreshold         | 直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配 |
| MaxTenuringThreshold           | 晋升到老年代的对象年龄，每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数时就进入老年代 |
| UseAdaptiveSizePolicy          | 动态调整Java堆中各个区域的大小以及进入老年代的年龄              |
| HandlePromotionFailure         | 是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况 |
| ParallelGCThreads              | 设置并行GC时进行内存回收的线程数                        |
| GCTimeRatio                    | GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效 |
| MaxGCPauseMillis               | 设置GC的最大停顿时间，仅在使用Parallel Scavenge收集器时生效  |
| CMSInitiatingOccupancyFraction | 设置CMS收集器在老年代空间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效 |
| UseCMSCompactAtFullCollection  | 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理，仅在使用CMS收集器时生效 |
| CMSFullGCsBeforeCompaction     | 设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效 |

## 3.6 内存分配与回收策略

​	自动内存管理最终可以归结为解决两个问题：给对象分配内存以及回收分配给对象的内存。

​	对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配 [1] ），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。

### 3.6.1 对象优先在Eden分配

​	大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。GC期间如果有需要分配的对象，而Survivor空间没有足够的空间分配，虚拟机会通过分配担保机制提前转移到老年代去。

​	虚拟机提供了-XX：+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。在实际应用中，内存回收日志一般是打印到文件后通过日志工具进行分析。

​	新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。

​	老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。

### 3.6.2 大对象直接进入老年代

​	所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。（比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免）

​	虚拟机提供了一个-XX：PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。

​	注意PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。

### 3.6.3 长期存活的对象进入老年代

​	既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。

### 3.6.4 动态对象年龄判断

​	为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

### 3.6.5 空间分配担保

​	在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。

​	为什么需要空间分配担保：新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。

​	老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。

​	取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。

​	在JDK 6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，虽然源
码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK 6 Update24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。

## 3.7 小结

​	内存回收与垃圾收集器在很多时候都是影响系统性能、并发能力的主要因素之一，虚拟机之所以提供多种不同的收集器以及提供大量的调节参数，是因为只有根据实际应用需求、实现方式选择最优的收集方式才能获取最高的性能。没有固定收集器、参数组合，也没有最优的调优方法，虚拟机也就没有什么必然的内存回收行为。因此，学习虚拟机内存知识，如果要到实践调优阶段，那么必须了解每个具体收集器的行为、优势和劣势、调节参数。

# 第四章 虚拟机性能监控与故障处理工具

## 4.1 JDK的命令行工具

​	在JDK的bin目录下有如“java.exe”、“javac.exe”等命令行工具，这些命令行工具大多数是jdk/lib/tools.jar类库的一层薄包装而已，它们主要的功能代码是在tools类库中实现的。Linux版本的JDK，这些工具中很多甚至就是由Shell脚本直接写成的，可以用vim直接打开它们。

​	JDK开发团队选择采用Java代码来实现这些监控工具是有特别用意的：当应用程序部署到生产环境后，无论是直接接触物理服务器还是远程Telnet到服务器上都可能会受到限制。借助tools.jar类库里面的接口，我们可以直接在应用程序中实现功能强大的监控分析功能 。

常用命令行工具：

| 工具     | 主要作用                                     |
| ------ | ---------------------------------------- |
| jps    | JVM Process Status Tool， 用于显示系统内所有的HotSpot虚拟机进程 |
| jstat  | JVM Statistics Monitoring Tool， 用于监控虚拟机各种运行状态信息的命令行工具 |
| jinfo  | Configuration Info for Java， 用于查看和调整虚拟机的配置参数 |
| jmap   | Memory Map for Java， 用于生成堆转储快照（一般称为heapdump或dump文件） |
| jhat   | JVM Heap Analysis Tool， 用于分析jmap生成的堆转储快照 |
| jstack | JVM Stack Trance， 用于生成虚拟机当前时刻的线程快照       |

### 4.1.1 jps：虚拟机进程状况工具

​	全称：JVM Process Status Tool

​	功能：可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class,main（）函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier,LVMID）。

​	虽然功能比较单一，但它是使用频率最高的JDK命令行工具，因为其他的JDK工具大多需要输入它查询到的LVMID来确定要监控的是哪一个虚拟机进程。对于本地虚拟机进程来说，LVMID与操作系统的进程ID（Process Identifier,PID）是一致的，使用Windows的任务管理器或者UNIX的ps命令也可以查询到虚拟机进程的LVMID，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，那就只能依赖jps命令显示主类的功能才能区分了。

​	命令格式：

```text
jps[options][hostid]
```

​	jps执行样例：

```text
D：\Develop\Java\jdk1.6.0_21\bin＞jps-l
2388 D：\Develop\glassfish\bin\..\modules\admin-cli.jar
2764 com.sun.enterprise.glassfish.bootstrap.ASMain
3788 sun.tools.jps.Jps
```

​	jps工具主要选项：

| 选项   | 作用                           |
| ---- | ---------------------------- |
| -q   | 只输出LVMID，省略主类名称              |
| -m   | 输出虚拟机进程启动时传递给主类main()函数的参数   |
| -l   | 输出全类名，如果进程执行的是Jar包，输出Jar包的路径 |
| -v   | 输出虚拟机进程启动时的JVM参数             |

###4.1.2 jstat：虚拟机统计信息监视工具

​	全称：JVM Statistics Monitoring Tool

​	功能：用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程 [1] 虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。

​	jstat命令格式：

```text
jstat[option vmid[interval[s|ms][count]]]
```

​	对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID是一致的，如果是远程虚拟机进程，那VMID的格式应当是：

```text
[protocol：][//]lvmid[@hostname[：port]/servername]
```

​	参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：

```text
jstat-gc 2764 250 20
```

​	jstat执行样例：

```text
D：\Develop\Java\jdk1.6.0_21\bin＞jstat-gcutil 2764
S0 S1 E O P YGC YGCT FGC FGCT GCT
0.00 0.00 6.20 41.42 47.20 16 0.105 3 0.472 0.577
```

​	查询结果表明：这台服务器的新生代Eden区（E，表示Eden）使用了6.2%的空间，两个Survivor区（S0、S1，表示Survivor0、Survivor1）里面都是空的，老年代（O，表示Old）和永久代（P，表示Permanent）则分别使用了41.42%和47.20%的空间。程序运行以来共发生Minor GC（YGC，表示Young GC）16次，总耗时0.105秒，发生Full GC（FGC，表示FullGC）3次，Full GC总耗时（FGCT，表示Full GC Time）为0.472秒，所有GC总耗时（GCT，表示GC Time）为0.577秒。

​	选项option代表着用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集、运行期编译状况:

| 选项                | 作用                                       |
| ----------------- | ---------------------------------------- |
| -class            | 监视类装载、卸载数量、总空间以及类装载所耗费时间                 |
| -gc               | 监视Java堆状况、包括Eden区、两个survivor区、老年代、永久代等容量、已用空间、GC时间合计等信息 |
| -gccapacity       | 监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间 |
| -gcutil           | 监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比        |
| -gccause          | 与-gcutil功能一样，但是会额外输出导致上一次GC的原因           |
| -gcnew            | 监视新生代GC状况                                |
| -gcnewcapacity    | 监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间        |
| -gcold            | 监视老年代GC状况                                |
| -gcoldcapacity    | 监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间        |
| -gcpermcapacity   | 输出永久代使用到的最大、最小空间                         |
| -compiler         | 输出JIT编译器编译过的方法、耗时等信息                     |
| -printcompilation | 输出已经被JIT编译的方法                            |

### 4.1.3 jinfo：Java配置信息工具

​	全称：Configuration Info for Java

​	功能：实时地查看和调整虚拟机各项参数。使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用jinfo的-flag选项进行查询了（如果只限于JDK 1.6或以上版本的话，使用java-XX：+PrintFlagsFinal查看参数默认值也是一个很好的选择），jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties（）的内容打印出来。JDK 1.6之后，jinfo在Windows和Linux平台都有提供，并且加入了运行期修改参数的能力，可以使用-flag[+|-]name或者-flag name=value修改一部分运行期可写的虚拟机参数值。

​	jinfo命令格式：

```text
jinfo[option]pid
```

​	执行样例：

```text
C：\＞jinfo-flag CMSInitiatingOccupancyFraction 1444
-XX：CMSInitiatingOccupancyFraction=85
```

### 4.1.4 jmap：Java内存映象工具

​	全称：Memory Map for Java

​	功能：命令用于生成堆转储快照（一般称为heapdump或dump文件）。jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。

​	如果不使用jmap命令，要想获取Java堆转储快照，还有一些比较“暴力”的手段：譬如在第2章中用过的-XX：+HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件，通过-XX：+HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件，又或者在Linux系统下通过Kill-3命令发送进程退出信号“吓唬”一下虚拟机，也能拿到dump文件。

​	jmap命令格式：

```	text
jmap[option]vmid
```

​	执行样例：

```text
C：\Users\IcyFenix＞jmap-dump：format=b,file=eclipse.bin 3500
Dumping heap to C：\Users\IcyFenix\eclipse.bin……
Heap dump file created
```

​	option选项的合法值与具体含义：

| 选项             | 作用                                       |
| -------------- | ---------------------------------------- |
| -dump          | 生成Java堆转储快照。格式为：-dump:[live,]format=b,file=<filename>,其中live子参数说明是否只dump出存活的对象。 |
| -finalizerinfo | 显示在F-Queue中等待Finalizer线程执行finalize方法的对象，只在Linux/Solaris平台下有效 |
| -heap          | 显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等，只在Linux/Solaris平台下有效 |
| -histo         | 显示堆中对象统计信息，包括类、实例数量、合计容量                 |
| -permstat      | 以Class Loader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效 |
| -F             | 当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效 |

### 4.1.5 jhat：虚拟机堆转储快照分析工具

​	全称：JVM Heap Analysis Tool

​	功能：与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。

​	在实际工作中，一般都不会去直接使用jhat命令来分析dump文件，主要原因有二：一是一般不会在部署应用程序的服务器上直接分析dump文件，即使可以这样做，也会尽量将dump文件复制到其他机器上进行分析，因为分析工作是一个耗时而且消耗硬件资源的过程，既然都要在其他机器进行，就没有必要受到命令行工具的限制了；另一个原因是jhat的分析功能相对来说比较简陋，VisualVM，以及专业用于分析dump文件的Eclipse Memory
Analyzer、IBM HeapAnalyzer等工具，都能实现比jhat更强大更专业的分析功能。

​	执行样例：

```text
C：\Users\IcyFenix＞jhat eclipse.bin
Reading from eclipse.bin……
Dump file created Fri Nov 19 22：07：21 CST 2010
Snapshot read,resolving……
Resolving 1225951 objects……
Chasing references,expect 245 dots……
Eliminating duplicate references……
Snapshot resolved.
Started HTTP server on port 7000
Server is ready.
```

​	屏幕显示“Server is ready.”的提示后，用户在浏览器中键入http://localhost：7000/就可以看到分析结果

### 4.1.6 jstack：Java堆栈跟踪工具

​	全称：Stack Trace for Java

​	功能：用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源。

​	jstack命令格式：

```text
jstack[option]vmid
```

​	option选项的合法值与具体含义:

| 选项   | 作用                       |
| ---- | ------------------------ |
| -F   | 当正常输出的请求不被响应时，强制输出线程堆栈   |
| -l   | 除堆栈外，显示关于锁的附加信息          |
| -m   | 如果调用到本地方法的话，可以显示C/C++的堆栈 |

​	执行样例：

```text
C：\Users\IcyFenix＞jstack-l 3500
2010-11-19 23：11：26
Full thread dump Java HotSpot（TM）64-Bit Server VM（17.1-b03 mixed mode）：
"[ThreadPool Manager]-Idle Thread"daemon prio=6 tid=0x0000000039dd4000 nid=0xf50 in Object.wait（）[0x000000003c96f000]
java.lang.Thread.State：WAITING（on object monitor）
at java.lang.Object.wait（Native Method）
-waiting on＜0x0000000016bdcc60＞（a org.eclipse.equinox.internal.util.impl.tpt.threadpool.Executor）
at java.lang.Object.wait（Object.java：485）
at org.eclipse.equinox.internal.util.impl.tpt.threadpool.Executor.run（Executor.java：106）
-locked＜0x0000000016bdcc60＞（a org.eclipse.equinox.internal.util.impl.tpt.threadpool.Executor）
Locked ownable synchronizers：
-None
```

​	在JDK 1.5中，java.lang.Thread类新增了一个getAllStackTraces（）方法用于获取虚拟机中所有线程的StackTraceElement对象。使用这个方法可以通过简单的几行代码就完成jstack的大部分功能，在实际项目中不妨调用这个方法做个管理员页面，可以随时使用浏览器来查看线程堆栈。

### 4.1.7 HSDIS：JIT生成代码反汇编

​	在Java虚拟机规范中，详细描述了虚拟机指令集中每条指令的执行过程、执行前后对操作数栈、局部变量表的影响等细节。这些细节描述与Sun的早期虚拟机（Sun Classic VM）高度吻合，但随着技术的发展，高性能虚拟机真正的细节实现方式已经渐渐与虚拟机规范所描述的内容产生了越来越大的差距，虚拟机规范中的描述逐渐成了虚拟机实现的“概念模型”——即实现只能保证规范描述等效。基于这个原因，我们分析程序的执行语义问题（虚拟机做了什么）时，在字节码层面上分析完全可行，但分析程序的执行行为问题（虚拟机是怎样做的、性能如何）时，在字节码层面上分析就没有什么意义了，需要通过其他方式解决。

​	分析程序如何执行，通过软件调试工具（GDB、Windbg等）来断点调试是最常见的手段，但是这样的调试方式在Java虚拟机中会遇到很大困难，因为大量执行代码是通过JIT编译器动态生成到CodeBuffer中的，没有很简单的手段来处理这种混合模式的调试（不过相信虚拟机开发团队内部肯定是有内部工具的）。

​	HSDIS是一个Sun官方推荐的HotSpot虚拟机JIT编译代码的反汇编插件，它包含在HotSpot虚拟机的源码之中，但没有提供编译后的程序。在Project Kenai的网站也可以下载到单独的源码。它的作用是让HotSpot的-XX：+PrintAssembly指令调用它来把动态生成的本地代码还原为汇编代码输出，同时还生成了大量非常有价值的注释，这样我们就可以通过输出的代码来分析问题。

​	可以根据自己的操作系统和CPU类型从Project Kenai的网站上下载编译好的插件，直接放到JDK_HOME/jre/bin/client和JDK_HOME/jre/bin/server目录中即可。如果没有找到所需操作系统（譬如Windows的就没有）的成品，那就得自己使用源码编译一下。

​	还需要注意的是，如果使用的是Debug或者FastDebug版的HotSpot，那可以直接通过-XX：+PrintAssembly指令使用插件；如果使用的是Product版的HotSpot，那还要额外加入一个-XX：+UnlockDiagnosticVMOptions参数。

​	测试代码：

```java
public class Bar{
	int a=1；
	static int b=2；
	public int sum（int c）{
		return a+b+c；
	}
  
	public static void main（String[]args）{
		new Bar（）.sum（3）；
	}
}
```

​	编译这段代码，并使用以下命令执行。

```text
java-XX：+PrintAssembly-Xcomp-XX：CompileCommand=dontinline，*Bar.sum-XX：Compi leCommand=compileonly，*Bar.sum test.Bar
```

​	其中，参数-Xcomp是让虚拟机以编译模式执行代码，这样代码可以“偷懒”，不需要执行足够次数来预热就能触发JIT编译 [3] 。两个-XX：CompileCommand意思是让编译器不要内联sum（）并且只编译sum（），-XX：+PrintAssembly就是输出反汇编内容。

​	如果执行顺利就会出现如下代码：

```text
[Disassembling for mach='i386']
[Entry Point]
[Constants]
#{method}'sum''（I）I'in'test/Bar'
#this：ecx='test/Bar'
#parm0：edx=int
#[sp+0x20]（sp of caller）
……
0x01cac407：cmp 0x4（%ecx），%eax
0x01cac40a：jne 0x01c6b050；{runtime_call}
[Verified Entry Point]
0x01cac410：mov%eax，-0x8000（%esp）
0x01cac417：push%ebp
0x01cac418：sub$0x18，%esp；*aload_0
；-test.Bar：sum@0（line 8）
；block B0[0，10]
0x01cac41b：mov 0x8（%ecx），%eax；*getfield a
；-test.Bar：sum@1（line 8）
0x01cac41e：mov$0x3d2fad8，%esi；{oop（a
'java/lang/Class'='test/Bar'）}
0x01cac423：mov 0x68（%esi），%esi；*getstatic b
；-test.Bar：sum@4（line 8）
0x01cac426：add%esi，%eax
0x01cac428：add%edx，%eax
0x01cac42a：add$0x18，%esp
0x01cac42d：pop%ebp
0x01cac42e：test%eax，0x2b0100；{poll_return}
0x01cac434：ret
```

逐行解释：

1）mov%eax，-0x8000（%esp）：检查栈溢。

2）push%ebp：保存上一栈帧基址。

3）sub$0x18，%esp：给新帧分配空间。

4）mov 0x8（%ecx），%eax：取实例变量a，这里0x8（%ecx）就是ecx+0x8的意思，前面“[Constants]”节中提示了“this：ecx='test/Bar'”，即ecx寄存器中放的就是this对象的地址。偏移0x8是越过this对象的对象头，之后就是实例变量a的内存位置。这次是访问“Java堆”中的数据。

5）mov$0x3d2fad8，%esi：取test.Bar在方法区的指针。

6）mov 0x68（%esi），%esi：取类变量b，这次是访问“方法区”中的数据。

7）add%esi，%eax和add%edx，%eax：做两次加法，求a+b+c的值，前面的代码把a放在eax中，把b放在esi中，而c在[Constants]中提示了，“parm0：edx=int”，说明c在edx中。

8）add$0x18，%esp：撤销栈帧。

9）pop%ebp：恢复上一栈帧。

10）test%eax，0x2b0100：轮询方法返回处的SafePoint。

11）ret：方法返回。

## 4.2 JDK的可视化工具

​	JDK中除了提供大量的命令行工具外，还有两个功能强大的可视化工具：JConsole和VisualVM，这两个工具是JDK的正式成员。

​	JConsole是在JDK1.5发布的虚拟机监控工具，VisualVM是在JDK1.6发布的多合一故障处理工具。

###4.2.1 JConsole：Java监视与管理控制台 

​	全称：Java Monitoring and Management Console

​	功能：一种基于JMX的可视化监视、管理工具。它管理部分的功能是针对JMX MBean进行管理。MBean可以使用代码、中间件服务器的管理控制台或者所有符合JMX规范的软件进行访问。这里着重介绍监视功能。

​	1.启动JConsole

​	通过JDK/bin目录下的“jconsole.exe”启动JConsole后，将自动搜索出本机运行的所有虚拟机进程，不需要用户自己再使用jps来查询了。双击选择其中一个进程即可开始监控，也可以使用下面的“远程进程”功能来连接远程服务器，对远程虚拟机进行监控。

​	进入JConsole主界面，可以看到主界面里共包括“概述”、“内存”、“线程”、“类”、“VM摘要”、“MBean”6个页签。

​	“概述”页签显示的是整个虚拟机主要运行数据的概览，其中包括“堆内存使用情况”、“线程”、“类”、“CPU使用情况”4种信息的曲线图，这些曲线图是后面“内存”、“线程”、“类”页签的信息汇总。

​	2.内存监控

​	“内存”页签相当于可视化的jstat命令，用于监视受收集器管理的虚拟机内存（Java堆和永久代）的变化趋势。

​	3.线程监控

​	“线程”页签的功能相当于可视化的jstack命令，遇到线程停顿时可以使用这个页签进行监控分析。线程长时间停顿的主要原因主要有：等待外部资源（数据库连接、网络资源、设备资源等）、死循环、锁等待（活锁和死锁）。

​	出现线程死锁之后，点击JConsole线程面板的“检测到死锁”按钮，将出现一个新的“死锁”页签

###4.2.2 VisualVM：多合一故障处理工具 

​	全称：All-in-One Java Troubleshooting Tool

​	功能：到目前为止随JDK发布的功能最强大的运行监视和故障处理程序。除了运行监视、故障处理外，还提供了很多其他方面的功能。如性能分析（Profiling），VisualVM的性能分析功能甚至比起JProfiler、YourKit等专业且收费的Profiling工具都不会逊色多少，而且VisualVM的还有一个很大的优点：不需要被监视的程序基于特殊Agent运行，因此它对应用程序的实际性能的影响很小，使得它可以直接应用在生产环境中。这个优点是JProfiler、YourKit等工具无法与之媲美的。

​	1.VisualVM兼容范围与插件安装

​	tgv基于NetBeans平台开发，因此它一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM可以做到：

- 显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。

- 监视应用程序的CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。

- dump以及分析堆转储快照（jmap、jhat）。

- 方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。

- 离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者处进行Bug反馈。

- 其他plugins的无限的可能性……

  ​

  虽然VisualVM是JDK1.6才发布的，但它具备很强的向下兼容能力，甚至能向下兼容至近10年前发布的JDK 1.4.2平台，这对无数已经处于实施、维护的项目很有意义。



自带的插件中心URL可能无法访问，需要去https://visualvm.github.io/pluginscenters.html根据JDK版本查找对应的URL地址