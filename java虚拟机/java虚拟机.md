---
typora-root-url: ..\img
---

#第一章 走进Java

##1.1 java的技术体系

1.广义上讲

​	Java、Clojure、JRuby、Groovy等运行于Java虚拟机上的语言及其相关的程序都属于Java技术体系中的一员。

2.传统意义来讲

​	Sun官方定义的技术体系包括：

​		1.Java程序设计语言

​		2.各种硬件平台上的Java虚拟机

​		3.Class文件格式

​		4.Java API类库

​		5.来自商业机构和开源社区的第三方Java类库

​	其中，Java程序设计语言、Java虚拟机、Java API三部分可以统称为JDK（Java Development Kit/Java软件开发工具包），JDK是支持Java程序开发的最小环境。另外可以将Java API类库中Java SE API子集和Java虚拟机这两部分统称为JRE（Java Runtime Environment/Java运行环境，JRE是支持Java程序运行的标准环境。

![java虚拟机图片1](/java虚拟机图片1.jpg)				



3.按照重点业务领域划分:

- Java Card:支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台。
- Java ME（Micro Edition）：支持Java程序运行在移动终端（手机、PAD）上的平台。对Java API有所精简，并加入了针对移动终端的支持，这个版本以前称为J2ME。
- Java SE（Standard Edition）：支持面向桌面级应用（如Windows下的应用程序）的Java平台。提供了完整的Java核心API，这个版本以前称为J2SE。
- Java EE（Enterprise Edition）：支持使用多层架构的企业应用（如ERP、CRM应用）的Java平台。除了提供Java SE API外，还对其做了大量的扩充并提供了相关的部署支持，这个版本以前称为J2EE。

##1.2 Java虚拟机

###1.Sun Classic VM

​	世界上第一款商用Java虚拟机。在JDK1.0中发布，只能使用纯解释器的方式来执行Java代码。要使用JIT编译器，就必须进行外挂。如果外挂了JIT编译器，JIT编译器就完全接管虚拟机的执行系统，解释器不在工作。

​	外挂的JIT编译器包括sunwjit、symantee JIT、shuJIT等。

​	由于解释器和编译器无法配合工作，如果使用编译器执行代码就需要对每一行代码进行编译，迫于响应时间的压力，这些编译器不能使用编译耗时较高的优化技术。因此这个阶段的虚拟机即使使用JIT编译器输出的本地代码，执行效率也和传统的C\C++相比有很大的差距。

###2.Exact VM

​	由于Classic VM的各种问题，sun的虚拟机团队在JDK1.2的solaris平台上发布过一款名为Exact VM的虚拟机。这款虚拟机已经具备了现代高性能虚拟机的雏形，如两级即使编译器、编译器与解释器混合工作模式等。该虚拟机因使用准确式内存管理（Exact Memory Management，也可以叫Non-Conservative/Accurate Memory Management）而得名。

​	准确式内存管理，即虚拟机可以知道内存中某个位置的数据具体是什么类型。如内存中有一个32位的整数123456，虚拟机能够准确地知道这个整数是一个数值为123456的整数还是一个reference类型的指向123456的内存地址。这样虚拟机就能在GC时准确判断堆上的数据是否还可能被使用。

​	由于使用了准确式内存管理，Exact VM抛弃了Classic VM基于handler的对象查找方式，这样每次定位对象都少了一次间接查找的开销，提升了执行的性能。

​	Classic VM使用基于handler的对象查找方式的原因是由于在进行FGC之后对象可能被移动，如果地址为123456的对象被移动到了654321地址，由于不知道内存中数据的类型，不知道哪些123456是reference的前提下，虚拟机不敢贸然把所有的123456改为654321，所以要使用句柄来保证reference的稳定性。

###3.HotSpot VM

​	虽然Exact VM有了很大的进步，但是只存在了很短暂的时间就被更优秀的HotSpot VM取代了。HotSpot VM在JDK1.2 中作为备选方案与classic VM、Exact VM共存，在JDK 1.3中取代Classic VM成为了默认虚拟机。

​	HotSpot VM是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用最广泛的Java虚拟机。HotSpot VM来自于一家名为Longview Technologies的小公司，后被Sun公司收购。

​	HotSpot VM继承了Sun公司前两款商用虚拟机的优点，如准确式内存管理等。也有许多自己新的技术优势，如热点代码探测技术。

​	HotSpot VM的热点代码探测技术可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以方法为单位进行编译。如果一个方法被频繁的调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。通过编译器和解释器恰当的协同工作，可以再最优化的程序响应时间与最佳执行性能中取得平衡，且无需等待本地代码输出才能执行程序。编译的时间压力也相对减小，有助于引入更多的代码优化技术，输出质量更高的本地代码。

### 4.sun公司的其他虚拟机

​	除了上面的服务器、桌面领域的商用虚拟机外，还在移动端、嵌入式市场发布过虚拟机产品。另外还有一类虚拟机仅仅作为研究、验证某种技术和观点，或者作为一些规范的标准实现而出现的不以商用为目的的虚拟机。

（1）KVM

​	强调简单、轻量、高度可移植，但运行速度较慢。在Android、iOS等手机平台上曾经得到广泛的应用。

（2）CDC/CLDC HotSpot VM

​	它希望在手机、电子书、PAD等设备上建立统一的Java编程接口，是整个Java ME的重要支柱。但是从目前Android、iOS二分天下来看，局面并不乐观。

（3）Squawk VM

​	运行于Sun SPOT（一种手持WiFi设备）和Java Card上。是一个Java代码比重很高的嵌入式虚拟机实现，其中类加载器、字节码验证器、垃圾收集器、解释器、编译器和线程调度都是Java语言来完成的，仅靠C语言来编写设备I/O和必要的本地代码。

（4）JavaInJava

​	一个实验性质的虚拟机。试图以Java语言来实现Java程序的运行环境。他必须运行在另一个宿主虚拟机上，内部没有JIT编译器，代码只能以解释器模式执行。在当时（20世纪末）主流虚拟机都存在性能问题，所以这款虚拟机的执行速度可想而知。

（5）Maxine VM

​	与JavaInJava非常相似。他几乎也全部都是以Java代码实现（只有用于启动JVM的加载器使用C语言编写）。比起JavaInJava，它有先进的JIT编译器和垃圾收集器，但是没有解释器。可在宿主模式或独立模式下执行，其执行效率已经接近了HotSopt Client VM的水平。

###5.JRockit VM/J9 VM

​	除了Sun之外，还有其他一些组织、公司也研发过不少的虚拟机实现。其中就最著名、规模最大的属于BEA和IBM。

（1）JRockit VM

​	BEA公司2002年从Appeal Virtual Machines公司收购的虚拟机，曾经号称世界上速度最快的Java虚拟机。BEA将其发展为专门为服务器硬件和服务器端应用场景高度优化的虚拟机。由于专注于服务器端应用，它不太关注程序启动速度，内部不包含解析器实现，所有代码都依靠即时编译器编译后执行。

​	此外，JRockit VM的垃圾收集器和MissionControl服务套件等部分的实现，在众多Java虚拟机中也一直处于领先水平。

（2）J9 VM

​	属于IBM公司，虽然不是IBM公司唯一的一款虚拟机，不过是目前IBM公司主力发展的虚拟机。与JRockit VM专注于服务端应用不同，J9 VM的市场定位与HotSpot比较接近，是一款设计上从服务器端到桌面应用再到嵌入式都全面考虑的多用途虚拟机。

​	J9 VM开发的目的是作为IBM公司各种Java产品的执行平台，它的主要市场是和IBM产品（如WebSphere等）搭配以及在IBM AIX和z/OS这些平台上部署的Java应用。

### 6.Azul VM/BEA Liquid VM

​	我们平时所说的高性能虚拟机是指HotSpot、JRockit、J9这些通用平台上的虚拟机，实际上还有一类特定硬件平台专有的虚拟机，这些才是高性能的武器。

（1）Azul VM

​	Azul Systems公司在HotSpot基础上进行了大量的改进，运行于该公司专有硬件Vega系统上的Java虚拟机。每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控GC时间的垃圾收集器，为专有硬件优化的线程调度等优秀特性。后来Azul Systems发布了Zing JVM，可以再通用x86平台上提供接近于Vega系统的特性。

（2）Liquid VM

​	是BEA公司开发，可以直接运行在自家Hypervisor系统上的JRickit VM的虚拟化版本，Liquid VM不需要操作系统的支持，自身实现了一个专用操作系统的必要功能，如文件系统、网络支持等。有虚拟机越过操作系统直接控制硬件，可以获得诸多好处，如线程调度时，不需要再进行内核态/用户态的切换，最大限度地发挥硬件能力，提升Java程序的执行效率。

###7.Harmony/Android Dalvik VM

（1）Harmony

​	Apache软件基金会旗下以Apache License协议开源的实际兼容于JDK1.5和JDK1.6的Java程序运行平台。它包含自己的虚拟机和Java库，可以在上面运行Eclipse、Tomcat、Maven等常见Java程序。可以说是Apache的JDK，但是由于没有通过TCK的兼容性测试而不能这样说。

​	虽然没有大规模商用，但是很多代码被吸纳进了IBM的JDK 7实现以及Google Android SDK中，尤其对Android的发展起到了很大的推动作用。

（2）Dalvik VM

​	Android让Java语言真正走进移动设备领域，虽然走的并非是sun公司原本想象的那条路。Dalvik VM是Android平台的核心组成部分之一。

​	Dalvik VM并不是一个Java虚拟机，他没有遵循Java虚拟机规范，不能直接执行Class文件。使用的是寄存器架构而不是JVM中常见的栈架构。但它又与Java有千丝万缕的联系，它执行的dex文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。

###8.Microsoft JVM

​	微软公司开发的虚拟机，是当时Windows下性能最好的Java虚拟机。主要应用之一是在浏览器中运行Java Applets程序，但是由于微软公司出于将Java绑定在Windows系统上的目的，与Java设计的初衷不符，导致sun公司与微软公司的官司，微软最终在Windows系统中彻底移除了对Java语言的支持。

### 9.其他

除了上述提到的虚拟机外，还有大量的Java虚拟机，如：

- JamVM
- cacaovm
- SableVM
- Kaffe
- Jelatine JVM
- NanoVM
- MRP
- Moxie JVM
- Jikes RVM
- 等等

##1.3 Java语言未来展望

###1.模块化

​	模块化是解决应用系统与技术平台越来越复杂、越来越庞大问题的一个重要途径。模块化已经在Java9中发布

###2.混合语言

​	当单一的Java开发已经无法满足当前软件的复杂需求时，越来越多基于Java虚拟机的语言开发被应用到软件项目中，Java平台上的多语言混合编程正在成为主流，每种语言都可以针对自己擅长的方面更好地解决问题。通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂项目需求的一个方向。

​	除了出现了大量运行于Java虚拟机的新语言之外，很多常见的语言也出现了基于Java虚拟机的实现版本，如C、PHP、Ruby、JavaScript、Python等等。

​	对于这些运行于Java虚拟机上的Java之外的语言，来自系统级、底层的支持也正在迅速增强，以JSR-292为核心的一系列项目和功能改进，正在推动Java虚拟机从Java语言的虚拟机向多语言的虚拟机转变。

###3.多核并行

​	CPU的发展已经从高频率转向多核心，随着多核时代的到来，软件开发越来越关注并行编程的领域。JDK1.5中java.util.concurrent包实现了一个粗粒度的并发框架。JDK1.7中java.util.concurrent.forkjoin包则对并发框架进行了重要的扩充。Fork/Join模式是一个处理并发编程的经典方法，虽然不能解决所有问题，但是在该模式适用的范围内，能够轻松的利用多个CPU核心提供的计算资源来协作完成一个复杂的计算任务。Fork/Join模式使我们能够顺利的过渡到多核时代。

​	Java8中提供Lambda表达式，极大的改善了Java语言不适合函数式编程的现状（在Lambda表达式出现之前，Java是通过内部类的形式实现函数式编程的，但是这样会使程序显得过于臃肿）。函数式编程的一个重要优点就是这样的程序天然适合并行运行，这对Java语言在多核时代继续保持主流语言的地位有很大的帮助。

​	目前显卡的算术运算能力、并行能力已经远远超过了CPU，在图形领域以外发掘显卡的潜力是近几年计算机发展的方向之一。OpenJDK的Sumatra子项目就是为Java提供GPU和APU运算能力的工具。以后它将会提供Java语言层面的API，或者为Lambda和其他JVM语言提供底层的并行运算支持。

​	此外还有一些如Hadoop Map Reduce等框架，运行于大型集群上以一种可靠地容错方式并行处理TB级别以上的数据集、另外，还有一些如Scala、Clojure、Erlang等天生就具备并行计算能力的语言。

###4.进一步丰富语法

在OpenJDK中建立的子项目Coin就是为了处理Java语法的细节修改。、

###5.64位虚拟机

虽然Java很早就推出了64位虚拟机，但是Java程序运行在64位虚拟机上需要付出较大的额外代价：

1.由于指针膨胀和各种数据类型对其补白的原因，Java程序运行于64位虚拟机上通常要多消耗10%~30%的内存。

2.64位虚拟机在运行速度上各个测试项几乎都落后于32位虚拟机，存在大约15%的性能差距。

所以64位Java虚拟机还需要进一步完善。



#第二章 Java内存区域与内存溢出异常

​	Java与C++相比具有内存动态分配和垃圾回收机制，在虚拟机自动内存管理机制下，Java程序不容易出现内存泄漏和内存溢出的问题。但是正是因为这个原因，如果出现了内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么将很难排查错误。

##2.1 运行时数据区域

![java虚拟机图片2](/java虚拟机图片2.jpg)

​	Java虚拟机在执行Java程序过程中，会把它所管理的内存划分为若干个不同的数据区域。这些数据区域都有各自的用途及生命周期。有的区域随虚拟机进程启动而存在，有些区域依赖于用户线程的启动和结束。Java的运行时内存区域大致可分为：虚拟机栈、本地方法栈、程序计数器、方法区、堆五个区域。其中方法区、堆是线程共享的数据区域。

###2.1.1 程序计数器

​	是一块较小的内存空间，可以看作是当前线程所执行字节码的行号指示器。

​	在虚拟机概念模型里，字节码解释器工作时就是通过改变计数器中的数值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等都需要依赖于这个计数器来完成。（只是概念模型，各个虚拟机可能会通过更高效的方式实现）

​	由于Java多线程会在多个线程中轮流切换执行，当线程恢复运行时，为了能恢复到正确的位置，每个线程都需要一个独立的计数器，使各个线程之间互不影响。所以这个区域不是线程共享的区域，我们称这类内存区域为“线程私有“区域。

​	如果一个线程正在执行的指令是Native方法，那么这是计数器的值为空（Undefined）。程序计数器是为执行Java字节码服务的，而本地方法都是由C等其他语言实现的，在执行本地方法时，大多都会直接映射到其原生平台上去执行，没有JVM什么事。

​	此内存区域是唯一一个Java虚拟机规范中没有规定任何OutOfMemoryError的区域。

###2.1.2 Java虚拟机栈

​	与程序计数器一样，Java虚拟机栈也是线程私有的，他的生命周期与线程相同。

​	Java虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时，都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程，就对应着一个栈帧从入栈到出栈的过程。

​	通常我们将Java内存模型分为堆和栈两部分，这是一种比较粗糙的分法，但是这两块内存区域确实是我们最关注的区域。而我们通常说的栈内存就是指的Java虚拟机栈或者说Java虚拟机栈的局部变量表部分。

####1.局部变量表

​	局部变量表中存放了编译器可知的各种基本数据类型、对象引用和returnAddress（指向一条字节码指令的地址）。returnAddress类型（返回地址类型），并不是Java语言API的一部分，会被Java虚拟机的jsr、ret和jsr_w指令所使用，并不会被程序员直接使用。returnAddress类型在Java语言之中并不存在相应的类型，也无法在程序运行期间更改returnAddress类型的值。

​	局部变量表是一组局部变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java文件编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。

​	其中64位长度的double和long类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用一个。局部变量表所需要的空间在编译期间完成分配，在运行期间不会再改变局部变量表的大小。

####2.操作数栈

​	操作数栈也常被称为操作栈，它是一个后入先出栈。JVM底层字节码指令集是基于栈类型的，所有的操作码都是对操作数栈上的数据进行操作，对于每一个方法的调用，JVM会建立一个操作数栈，以供计算使用。和局部变量一样，操作数栈的最大深度也是编译的时候写入到方法表的code属性的max_stacks数据项中。

​	操作数栈的每一个元素可以是任意的Java数据类型，包括long、double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。栈容量的单位为“字宽”，对于32位虚拟机来说，一个“字宽”占4个字节，64位虚拟机来说，一个“字宽”占8个字节。

​	当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指向操作数栈中写入和提取值，也就是入栈与出栈操作。例如，在做算术运算的时候就是通过操作数栈来进行的，又或者调用其它方法的时候是通过操作数栈来行参数传递的。

​	另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是大多数虚拟机的实现里都会作一些优化处理，令两个栈帧出现一部分重叠。让下栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用返回时就可以共用一部分数据，而无须进行额外的参数复制传递了。

####3.动态链接

​	 每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。

​	编译是将将预处理生成的文件，经过词法分析、语法分析、语义分析以及优化后编译成若干个目标模块。可以理解为将高级语言翻译为计算机可以理解的二进制代码，即机器语言。链接是将编译后形成的一组目标模块以及它们所需要的库函数链接在一起，形成一个完整的载入模型。链接主要解决模块间的相互引用问题。链接一般分为静态链接、载入时动态链接以及运行时动态链接三种。

####4.方法出口

​	当一个方法被执行后，有两种方式退出这个方法。

​	第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者(调用当前方法的的方法称为调用者)，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口(Normal Method Invocation Completion)。

​	另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口(Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。

​	无论采用何种方式退出，在方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。

​	方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用都栈帧的操作数栈中，调用PC计数器的值以指向方法调用指令后面的一条指令等。

####5.附加信息

​	虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。

####6.异常

​	在Java虚拟机栈这个区域，Java虚拟机规范规定了两种异常状况。

​	如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverflowError异常。

​	如果虚拟机栈可以动态扩展（当前大部分虚拟机都可以动态扩展，但是Java虚拟机规范允许固定长度的虚拟机栈），在扩展时无法申请到足够的内存，会抛出OutOfMemoryError异常。

###2.1.3 本地方法栈	

​	与Java虚拟机栈作用相似，Java虚拟机栈是为了Java虚拟机执行Java方法（也就是字节码）服务，而本地方法栈是为Java虚拟机执行Native方法服务。

​	在Java虚拟机规范中，并没有对本地方法栈中方法使用的语言、使用方式以及数据结构的强制规范，所以允许虚拟机自由实现它。在HotSpot虚拟机中，将虚拟机栈和本地方法栈合二为一。

​	在本地方法栈中，也会抛出StackOverflowError和OutOfMemoryError。

###2.1.4 Java堆

​	对于大多数应用来说，Java堆是Java虚拟机所管理内存区域内最大的一块。Java堆是被所有线程共享的一块区域，在虚拟机启动的时候创建。Java堆内存唯一的目的就是用来存放对象实例，几乎所有的对象实例都是在Java堆中分配内存。在Java虚拟机规范中描述是：所有的对象实例以及数组都要在堆上分配。但是随着JIT编译器的发展与逃逸技术的逐渐成熟，栈上分配、标量替换优化技术将导致所有对象都在堆上分配不再绝对。

​	Java堆是垃圾收集器管理的主要区域，因此也被称为”GC堆“。

​	从内存回收的角度来看，由于现在垃圾收集器基本都采用分代收集算法，所依堆还可以细分为新生代和老年代。再细致一点有Eden空间、From Survivor空间、To Survivor空间等。

​	从内存分配的角度来看，Java堆中还能划分出多个线程私有的分配缓冲区。

​	无论怎么划分，本质上Java堆还是存储的对象实例，划分的目的是为了更好的回收内存或者更快的分配内存。

​	Java虚拟机规范中规定，Java堆可以处在物理上不连续的内存空间中，只需要逻辑上是连续的即可。既可以实现为固定大小，也可以是可扩展的（主流的虚拟机都是可扩展的）。

​	如果堆中没有内存再分配给对象实例，且堆无法继续扩展，将会抛出OutOfMemoryError异常。

### 2.1.5 方法区

​	方法区和Java堆一样，也是线程共享的一块内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

​	在Java虚拟机规范中，方法区被描述为Java堆的一个逻辑部分，但是它有一个别名叫作Non-Heap（非堆）。

​	对于HotSpot虚拟机开发而言，方法区经常被称为永久代。这仅仅是因为HotSpot虚拟机将GC分代收集扩展到了方法区，或者说用永久代来实现方法区，这样HotSpot的垃圾收集器可以像管理Java堆一样来管理方法区，省去了专门为方法区编写内存管理代码的工作。对于JRockit、J9等其他虚拟机而言，并不存在永久代这个概念。

​	原则上，如何实现方法区属于虚拟机实现细节，并不受虚拟机规范约束，但是使用永久代来实现方法区并不是个好主意，这样更容易出现内存溢出。因为永久代有-XX:MaxPermSize上限限制内存大小，而其他虚拟机只要没有碰到进程可用内存上限，就可以继续给方法区分配内存。HotSpot也有计划放弃永久代，改为采用Native Memory来实现方法区。在JDK 1.7中，已经把原来放在永久代中的字符串常量池移出，移到了堆中。

​	与Java堆一样，Java虚拟机规范对方法区的规定非常宽松，如不需要物理连续的内存空间，可以固定内存大小也可以可扩展，甚至还可以选择不实现垃圾收集。垃圾回收行为在这个区域较少出现，但是也并不是真如永久代的名字一样永久，在这个区域垃圾回收的主要目标是针对常量池的回收以及对类型的卸载。当时一般来说，对这个区域的垃圾回收比较难以令人满意，尤其是类型卸载，条件相当苛刻，当时这个区域的垃圾回收是相当有必要的。Sun公司的BUG列表中出现过多个严重BUG就是因为对这个区域的内存回收不完全导致的内存溢出。

​	Java虚拟机规范规定，方法区无法满足内存分配需求时，抛出OutOfMemoryError异常。

### 2.1.6 运行时常量池

​	方法区的一部分。Class文件中出了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池中存放。

​	Java虚拟机对Class文件的每一个部分都有严格的规定，每个字节用来存储那种数据都必须严格符合规范上的要求才能被虚拟机认可，装载并执行。但是虚拟机规范并没有对运行时常量池作出任何细节上的要求，由各个虚拟机自由实现，但是一般而言，运行时常量池出了保存class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。

​	 Java中的符号引用，编译时并不知道引用的地址，而是只有符号。只有在运行时才能把各个符号引用翻译为直接引用。直接引用和虚拟机的具体实现有关，可以是直接指向目标的指针、相对偏移量、一个间接定位到对象的句柄。

​	相对于Class文件的常量池，运行时常量池具备一个重要特征就是动态性。在Java语言中，常量并不要求在编译期间产生，也就是说并只有Class文件常量池中的内容才能进入运行时常量池，程序运行过程中也可能有新的常量被放入池中。用的较多的就是String类的intern()方法。

​	既然是方法区的一部分，那么运行时常量池在无法继续分配内存时，也会抛出OutOfMemoryError异常。

###2.1.7 直接内存

​	直接内存并不是虚拟机运行时内存的一部分，也不是Java虚拟机规范中定义的内存区域，但是它也被经常使用，也可能导致OutOfMemoryError异常。

​	在JDK 1.4中加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式。它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆内的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提升性能，因为避免了在Java堆和Native堆中来回复制数据。

​	直接分配本机内存不会受到Java堆大小的限制，但是只要是内存，就要受到机器总内存的限制。在配置虚拟机内存时，会根据实际内存设置-Xmx等参数，但是忽略了直接内存，使得各个内存区域的总和大于物理内存限制导致OutOfMemoryError异常。

##2.2 Java虚拟机中的对象

###2.2.1 对象的创建

​	在Java中有五种创建对象的方式。

| 方式                           | 是否调用构造方法 |
| ---------------------------- | -------- |
| 使用new关键字                     | 是        |
| 使用Class类的newInstance方法       | 是        |
| 使用Constructor类的newInstance方法 | 是        |
| 使用clone方法                    | 否        |
| 使用反序列化                       | 否        |

当虚拟机遇到一条new指令时的执行步骤：

####1. 类加载检查

首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用所代表的类是否被加载、解析和初始化过。如果没有，那么要先执行类加载过程。

#### 2.分配内存

1.分配方式

通过类加载检查后，虚拟机将会给新对象分配内存。新对象所需的内存空间大小在类加载完成后就可以完全确定。分配内存空间的过程相当于从Java堆中把一块确定大小的内存划分出来。有两种分配方式：

（1）指针碰撞

如果Java堆中的内存是绝对规整的，即所有内存空间都是连续的，被用过的放在一边，空闲内存放在另一边，中间放着一个指针作为分界点的指示器。那么仅仅需要将指针那空闲内存一侧移动对象大小的距离。

（2）空闲列表

如果Java堆中的内存不是规整的，已用内存与空闲内存相互交错，虚拟机就必须维护一个列表，记录哪些内存块是可用的。分配的时候从列表中找出一块足够大的空间划分给对象，并更新列表。

采用什么方式分配内存由内存空间是否规整决定，而内存空间是否规整又是由垃圾收集器是否带有压缩整理功能决定。因此采用Serial、ParNew等带有Compact过程的垃圾收集器时，内存分配的算法是指针碰撞；而使用CMS这种基于Mark-Sweep算法的垃圾收集器时，通常采用的是空闲列表。

2.线程安全

内存分配过程中，还会遇到一个线程安全问题，例如同时给对象A和对象B分配内存，对象A分配了内存指针还没有来得及修改，对象B又同时使用了原来位置的指针来分配内存。为了解决这个问题，有两种方案。

（1）同步

对分配内存过程进行同步处理。虚拟机采用CAS配上失败重试的方法保证更新操作的原子性。

（2）线程分配缓冲

给每个线程在Java堆中预先分配一小块内存区域，称为本地线程分配缓冲。线程需要分配内存，就在该线程的缓冲区分配，直到这个区域使用完，才需要同步锁定，再次分配给该线程分配一个缓冲区。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB来设置。

####3.内存空间初始化

内存分配完成后，虚拟机需要将分配到的区域都初始化为零值（不包括对象头），如果采用了TLAB，这个步骤也可以提前到TLAB分配时。这步操作保证了对象的实例字段在Java代码中不赋初始值就能直接使用。

####4.对象头信息设置

初始化完成后，虚拟机要对对象进行必要的设置，例如对象是哪个类的实例、如何才能找到类的元数据、对象的哈希码、对象的GC分代年龄等信息等，这些信息存放在对象的对象头中。

####5.对象初始化

完成上述步骤，从虚拟机的视角来看，一个新对象已经产生了，而从Java程序的视角来看，对象创建才刚刚开始，初始化方法还没执行。所以执行new指令后，还会执行初始化方法，按照程序员的意愿对对象进行初始化，这样对象才能被使用。

### 2.2.2 对象的内存布局

对象的内存大致可以分为三个区域：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。

#### 1.对象头

对象头包括两个部分。

（1）Mark Word

​	第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据长度在32位虚拟机和64位虚拟机（未开启压缩指针）中分别是32bit和64bit，官方称为“Mark Word“。

​	实际上，对象需要存储的运行时数据已经超出了32bit、64bit结构所能记录的限度。由于这一部分是与对象自身定义数据无关的额外存储成本，出于空间利用效率考虑，这部分被设计成了一个非固定的数据结构以便在极小的空间内存储尽可能多的信息，他会根据对象的状态复用自己的存储空间。HotSpot虚拟机对象头的MarkWord见下表：

| 存储内容                | 标志位  | 状态        |
| ------------------- | ---- | --------- |
| 对象哈希码、对象分代年龄        | 01   | 未锁定       |
| 指向锁定记录的指针           | 00   | 轻量级锁定     |
| 指向重量级锁的指针           | 10   | 膨胀（重量级锁定） |
| 空，不需要记录信息           | 11   | GC标记      |
| 偏向线程ID、偏向时间戳、对象分代年龄 | 01   | 可偏向       |

（2）类型指针

​	对象头的另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。并不是所有虚拟机实现都必须在对象数据上保留类型指针，查找对象的元数据并不一定要经过对象本身。

（3）数组

​	如果对象是一个Java数组，那么对象头中还必须有一块用于记录数组长度的数据，因为Java虚拟机可以通过对象的元数据信息确定普通Java对象的大小，但是无法从数据的元数据确定数组的大小。

#### 2.实例数据

​	实例数据部分是真正存储有效信息的部分，也就是在程序代码中定义的各种类型的字段内容。无论是从父类继承来的还是在类中定义的都需要在这部分记录下来。

​	这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略是longs/doubles、ints、shorts\chars、bytes\booleans、oops（Ordinary Object Pointers），从分配策略可以看出，相同宽度的字段总是分配到一起。在满足这个条件的情况下，父类中定义的变量会出现在子类之前。此外CompactFields参数设置为true（默认为true），那么子类中较窄的变量也可能会插入到父类变量的空隙中。

####3.对齐填充

第三部分对齐填充并不是必然存在的，也没有特别的含义，仅仅起着占位符的作用。HotSpot虚拟机自动内存管理系统要求对象的起始地址必须是8字节的整数倍。所以当对象的长度没有对齐的时候，就需要对齐填充来补全。

### 2.2.3 对象访问定位

​	在Java程序中，需要通过栈上的reference数据来操作堆上的具体对象。但是在Java虚拟机规范中只规定了reference类型是一个指向对象的引用，并没有定义这个引用通过何种方式对定位、访问堆中对象的具体位置，所以对象访问方式也是取决于虚拟机的具体实现。目前，主流的访问方式有使用句柄和直接指针两种。

####1.两种定位、访问方式

（1）使用句柄

使用句柄，会在Java堆中划出一块内存用来作为句柄池，reference中存储的就是对象的句柄地址，而句柄包含了对象实例数据与类型数据各自的具体地址信息。

![java虚拟机图片3](/java虚拟机图片3.jpg)

（2）直接指针

如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的就直接是对象的地址。

![java虚拟机图片4](/java虚拟机图片4.jpg)

#### 2.两种方式各自的优势

​	使用句柄来访问对象最大的好处就是reference中储存的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。在垃圾收集时移动对象是非常普遍的行为。

​	直接指针方式的最大好处就是速度快，相比于句柄方式少了一次指针定位的时间开销。由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项非常可观的执行成本。

#### 3.HotSpot的对象访问方式

​	就HotSpot而言，使用的是直接指针方式进行对象访问，但是对于整个软件开发范围来看，各种语言和框架使用句柄来访问的情况也非常常见。

## 2.3 OutOfMemoryError异常

​	在Java虚拟机中，除了程序计数器外，其他所有的内存区域都可能会出现OOM异常。

### 2.3.1 Java堆溢出

​	可以通过设置参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常是Dump出当前的内存堆转储快照以便事后进行分析。

​	Java堆内存的OOM异常是最常见的一种内存溢出情况。当出现异常时会进一步跟着“Java heap space”提示是堆内存出现内存溢出。

​	解决这个区域的异常，一般是先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出的堆转储快照进行分析，重点是确认内存中的对象是否是必需的，也就是说先分清楚是出现了内存泄漏还是内存溢出。

​	如果是内存泄漏，可以进一步通过工具查看泄漏对象到GC Roots的引用链。通过引用链就能找出垃圾收集器无法回收的原因，也就便于准确地定位出泄露代码的位置。

​	如果不是内存泄漏，那么内存中的对象都还必须或者，那就应当检查虚拟机的堆参数（-Xmx与-Xms），看是否能够调大。从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期间的内存消耗。

### 2.3.2 虚拟机栈和本地方法栈溢出

​	对于HotSpot来说，不区分虚拟机栈和本地方法栈，栈容量通过-Xss参数来调节。

​	虽然虚拟机规范中规定了OutOfMemoryError与StackOverflowError两种异常，但实际实验表明，单线程下，无论是栈深度大于虚拟机允许的最大深度还是虚拟机扩展栈空间时无法申请到足够的空间，都只会抛出StackOverflowError异常。

​	多线程的情况下，通过增加线程可能出现OutOfMemoryError异常。在不能减少线程数或加大物理内存的情况下，只能通过减少最大堆和减少栈容量的换取更多的线程。

### 2.3.3 方法区和运行时常量池溢出

​	当前很多主流框架，如Spring、Hibernate，在对类进行增强时，都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的class可以加载入内存。

​	方法区溢出也是一种常见的内存溢出，尤其在经常动态生成大量Class的应用中。因为一个类要被回收，判定的条件较为苛刻。

​	容易出现方法区溢出的程序包括：

​	1.使用了CGLib字节码技术

​	2.动态语言应用

​	3.大量JSP或动态生成JSP文件的应用（JSP第一次运行也会被编译为Java类）

​	4.易于OSGi的应用

### 2.3.4 本机直接内存溢出

​	DirectMemory容量可以通过-XX：MaxDirectMemorySize指定。如果不指定默认与Java堆的最大值一样。

​	DirectMemory的内存溢出，一个明显的特征是在Heap Dump文件中不会看到明显的异常。如果发现OOM之后的Dump文件很小，而程序中又直接或间接使用了NIO，那就要考虑是不是直接内存溢出了。

# 第三章 垃圾收集器与内存分配策略

## 3.1 概述

### 1.GC所要关注的问题

- 哪些内存需要回收
- 什么时候回收
- 如何回收

### 2.为什么要了解GC和内存分配

目前，内存的动态分配与内存回收技术已经相当成熟，一切看似都进入了“自动化”的时代。我们了解GC和内存分配的目的在于，当出现内存泄漏、内存溢出等问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们需要对这些“自动化”技术实施必要的监控和调节。

##3.2 哪些内存需要回收

### 3.2.1 对象

​	垃圾回收工作的主要区域是Java堆，而堆的唯一目的就是存储对象。垃圾收集器在对堆进行回收之前，首先要进行的是确定哪些对象可以被回收。两种算法：引用计数算法和可达性分析算法。

####1.判断是否回收

#####1.1 引用计数算法

​	在堆中存储对象时，在对象头处维护一个counter计数器，如果一个对象增加了一个引用与之相连，则将counter++。如果一个引用关系失效则counter–。如果一个对象的counter变为0，则说明该对象已经被废弃，不处于存活状态。

​	引用计数算法实现简单，判定效率也很高，在大多数情况下这是一个不错的算法。但是，主流的Java虚拟机里面都没有选用引用计数算法来管理内存。原因如下：

​	1.相互循环引用无法回收

​	其中最主要的原因是它很难解决对象之间相互循环引用的问题。

​	例如，对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。

​	2.多类型引用

​	 jdk从1.2开始增加了多种引用方式：软引用、弱引用、虚引用，且在不同引用情况下程序应进行不同的操作。如果我们只采用一个引用计数法来计数无法准确的区分这么多种引用的情况。

​	引用计数法无法解决多种类型引用的问题。但这并不是致命的，因为我们可以通过增加逻辑区分四种引用情况，虽然麻烦一些但还算是引用计数法的变体，真正让引用计数法彻底报废的还是因为循环引用问题。

#####1.2 可达性分析算法

​	在主流的商用程序语言中(Java和C#)，都是使用可达性分析算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

![java虚拟机图片5](/java虚拟机图片5.jpg)

​	如上图中，Object1、2、3是存活对象，而Object4、5、6虽然还有别的对象持有引用，但是由于没有引用链到达GC Roots对象，所以是可回收对象。

​	可以作为GC Roots的对象：

1. 虚拟机栈(栈桢中的本地变量表)中的引用的对象
2. 方法区中的类静态属性引用的对象
3. 方法区中的常量引用的对象
4. 本地方法栈中JNI（Native方法）的引用的对象

#####1.3 引用

​	无论是使用引用计数算法还是可达性分析算法，判定对象是否存活都与对象的引用密切相关。

​	在JDK1.2以前，Java对引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。

​	这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。

​	在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。从而使程序能更加灵活地控制对象的生命周期。

​	1.强引用就是指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 

```java
String str = new String("强引用");//str就是一个强引用，也是我们平时使用最多，存在最普遍的一类引用
```

​	2.软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。

```java
// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，
// 这里的软引用指的是指向new String("str")的引用，也就是SoftReference类中T
// 软引用所指向的对象在内存不足的时候会被回收
SoftReference<String> wrf = new SoftReference<String>(new String("str"));
```

​	使用场景：创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。PS：图片编辑器，视频编辑器之类的软件可以使用这种思路。

​	比如考虑一个图像编辑器的程序。该程序会把图像文件的全部内容都读取到内存中，以方便进行处理。而用户也可以同时打开多个文件。当同时打开的文件过多的时候，就可能造成内存不足。如果使用软引用来指向图像文件内容的话，垃圾回收器就可以在必要的时候回收掉这些内存。

```java
public class ImageData {
    private String path;
    private SoftReference<byte[]> dataRef;
    public ImageData(String path) {
        this.path = path;
        dataRef = new SoftReference<byte[]>(new byte[0]);
    }
    private byte[] readImage() {
        return new byte[1024 * 1024]; //省略了读取文件的操作
    }
    public byte[] getData() {
        byte[] dataArray = dataRef.get();
        if (dataArray == null || dataArray.length == 0) {
            dataArray = readImage();
            dataRef = new SoftReference<byte[]>(dataArray);
        }
        return dataArray;
    }
}
```

​	3.弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。

​	它的作用是引用一个对象，但是并不阻止该对象被回收。在垃圾回收器运行的时候，如果一个对象的所有引用都是弱引用的话，该对象会被回收。弱引用的作用在于解决强引用所带来的对象之间在存活时间上的耦合关系。弱引用最常见的用处是在集合类中，尤其在哈希表中。哈希表的接口允许使用任何Java对象作为键来使用。当一个键值对被放入到哈希表中之后，哈希表对象本身就有了对这些键和值对象的引用。如果这种引用是强引用的话，那么只要哈希表对象本身还存活，其中所包含的键和值对象是不会被回收的。如果某个存活时间很长的哈希表中包含的键值对很多，最终就有可能消耗掉JVM中全部的内存。对于这种情况的解决办法就是使用弱引用来引用这些对象，这样哈希表中的键和值对象都能被垃圾回收。Java中提供了WeakHashMap来满足这一常见需求。

```java
WeakReference<String> wrf = new WeakReference<String>(new String("str"));
```

​	4.虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。

​	对象终止机制：在Object类里面有个finalize方法，其设计的初衷是在一个对象被真正回收之前，可以用来执行一些清理的工作。因为Java并没有提供类似C++的析构函数一样的机制，就通过 finalize方法来实现。但是问题在于垃圾回收器的运行时间是不固定的，所以这些清理工作的实际运行时间也是不能预知的。

​	幽灵引用（phantom reference）可以解决这个问题。在创建幽灵引用PhantomReference的时候必须要指定一个引用队列。当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了。

​	幽灵引用及其队列的使用情况并不多见，主要用来实现比较精细的内存使用控制，这对于移动设备来说是很有意义的。程序可以在确定一个对象要被回收之后，再申请内存创建新的对象。通过这种方式可以使得程序所消耗的内存维持在一个相对较低的数量。比如下面的代码给出了一个缓冲区的实现示例。

```java
public class PhantomBuffer {
  private byte[] data = new byte[0];
    private ReferenceQueue<byte[]> queue = new ReferenceQueue<byte[]>();
    private PhantomReference<byte[]> ref = new PhantomReference<byte[]>(data, queue);
    public byte[] get(int size) {
        if (size <= 0) {
            throw new IllegalArgumentException("Wrong buffer size");
        }
        if (data.length < size) {
            data = null;
            System.gc(); //强制运行垃圾回收器
             try {
                queue.remove(); //该方法会阻塞直到队列非空
                ref.clear(); //幽灵引用不会自动清空，要手动运行
                ref = null;
                data = new byte[size];
                ref = new PhantomReference<byte[]>(data, queue);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
       }
       return data;
    }
}
```

​	在上面的代码中，每次申请新的缓冲区的时候，都首先确保之前的缓冲区的字节数组已经被成功回收。引用队列的remove方法会阻塞直到新的幽灵引用被加入到队列中。不过需要注意的是，这种做法会导致垃圾回收器被运行的次数过多，可能会造成程序的吞吐量过低。

​	

​	引用队列：在有些情况下，程序会需要在一个对象的可达到性发生变化的时候得到通知。比如某个对象的强引用都已经不存在了，只剩下软引用或是弱引用。但是还需要对引用本身做一些的处理。典型的情景是在哈希表中。引用对象是作为WeakHashMap中的键对象的，当其引用的实际对象被垃圾回收之后，就需要把该键值对从哈希表中删除。有了引用队列（ReferenceQueue），就可以方便的获取到这些弱引用对象，将它们从表中删除。在软引用和弱引用对象被添加到队列之前，其对实际对象的引用会被自动清空。通过引用队列的poll/remove方法就可以分别以非阻塞和阻塞的方式获取队列中的引用对象。

####2.finalize方法

​	即使在可达性分析中的不可达对象，也不是“非死不可”，而只是进入了缓刑阶段。在对象真正死亡，被回收之前需要经历至少两次标记：

​	1.标记不可达对象

​	首先在可达性分析后，如果对象没有与GC Roots对象相关联的引用链，那么它将会被第一次标记并进行一次筛选。

​	2.判断是否有必要执行finalize方法

​	筛选的条件是该对象是否有必要执行finalize方法。如果对象没有覆盖finalize方法或者finalize方法已经被虚拟机执行过一次了，那么虚拟机会视为没有必要执行。

​	3.执行finalize方法

​	如果判定为有必要执行finalize方法，那么这个对象就会被放置到一个叫F-Queue的队列中，稍后虚拟机会自动建立一个低优先级的Finalizer线程去执行它。这里的“执行”是指虚拟机会触发这个方法，但是不承诺会等待他执行结束。原因是如果一个对象的finalize方法执行缓慢，或者发生死循环，将可能导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。

​	finalize方法是对象逃脱死亡命运的最后一次机会，如果对象在finalize方法中拯救了自己（重新与引用链上的任意一个对象关联），那么GC第二次对F-Queue队列中对象标记时，会将这部分对象移出“即将回收”集合。这时仍被标记的对象，基本上就真的被回收了。

​	对任何一个对象的finalize方法都只会被系统自动调用一次，如果下一次对象面临回收，它的finalize方法不会被再次执行。

​	另外，并不鼓励使用finalize方法来拯救对象，而是尽量避免使用它。他不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时。可以完全忘记Java中有finalize方法的存在。

###3.2.2 方法区

​	很多人认为方法区（HotSpot中的永久代）是没有垃圾收集的，Java虚拟机规范中也说过不要求虚拟机在方法区实现垃圾收集。在方法区中的垃圾收集性价比较低。在堆中，尤其是新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而方法区的垃圾收集效率远低于此。

​	方法区的垃圾收集主要是回收废弃常量和无用的类两部分内容。

​	1.回收废弃常量

​	回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。

​	2.回收无用的类

​	回收废弃常量的判定条件比较简单，但是判定无用的类就相对复杂，需要满足以下三个条件才能算是“无用的类”：

​	（1）该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。

​	（2）加载该类的ClassLoader已经被回收。	

​	（3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

​	虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose：class以及-XX：+TraceClassLoading、-XX：+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。

​	在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。



##3.3 垃圾收集算法

###3.3.1 标记-清除算法

​	标记-清除算法是最基础的垃圾收集算法，算法分为两个阶段：标记和清除。首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。后续的收集算法都是基于这种思路并对其不足进行改进而得到的。

​	它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

![java虚拟机图片6](/java虚拟机图片6.jpg)

###3.3.2 复制算法

​	为了解决效率问题，出现了一种称为“复制”的算法，他将内存空间分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的这一块内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。

![java虚拟机图片7](/java虚拟机图片7.jpg)

​	现代的商业虚拟机都采用复制算法来回收新生代。IBM公司的研究表明，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间。每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上最后清理掉Eden和刚才用过的Survivor空间。

​	HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。

​	由于在98%的情况下都能正常运行，分配担保只是为了应对少数出现的另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象的情况。这些对象将直接通过分配担保机制进入老年代。

###3.3.3 标记-整理算法

​	复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

​	根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

![java虚拟机图片8](/java虚拟机图片8.jpg)

###3.3.4 分代收集算法

​	当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

​	在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。



##3.4 HotSpot中的算法实现

###3.4.1 枚举根节点

​	要进行可达性分析，首先要找到GC Roots对象。现在很多应用仅方法区就有几百兆，要逐个检查里面的所有引用，是一个非常耗时的操作。

​	另外，在进行可达性分析的时候，必须要确保在一个一致性的快照中进行（这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，否则就无法保证分析的准确性）。这点是导致在GC时必须停顿所有的Java执行线程（Sun将这件事情称为“Stop The World”）的其中一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。

​	在目前的主流Java虚拟机中，都是采用的准确式内存管理。所以在所有执行线程停顿下来枚举根节点的时候，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。

​	通过准确式内存管理（HotSpot中是使用一组称为OopMap的数据结构来实现的），减少了枚举根节点的耗时，所有执行线程停顿的时间变短，GC的效率更高。

###3.4.2 安全点

​	在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。	

​	实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。

​	Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。

​	对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。

​	抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。

​	而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。

###3.4.3 安全区域

​	使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。

​	安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。

​	在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。

##3.5 垃圾收集器

​	垃圾收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。对于垃圾收集器的实现Java虚拟机规范中并没有任何规定，因此不同厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大区别，并且一般都会提供参数供用户根据自己应用的特点和要求组合出各个年代所使用的收集器。

​	这里主要介绍JDK1.7 Update14之后的HotSpot的虚拟机，下图中存在连线的虚拟机可以搭配使用。

![java虚拟机图片9](/java虚拟机图片9.jpg)

​	各个垃圾收集器各有特点，并没有最好的垃圾收集器，更没有万能的垃圾收集器，我们只能根据需要去选择最适合的垃圾收集器。

###3.5.1 垃圾收集器名词说明

#### 1.并行（Parallel）

​	这里的并行指多条垃圾收集线程同时工作，但是此时用户线程仍然处于等待状态。

#### 2.并发（Concurrent）

​	这里的并发指用户线程与垃圾收集线程同时执行（但不一定是并发的，可能是交替执行），用户线程在继续运行，而垃圾收集程序运行于另一个CPU上。

#### 3.吞吐量（Throughput）

​	这里的吞吐量指CPU用于执行用户代码的时间与CPU总消耗时间的比值。即吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集时间）。	

###3.5.2 Serial收集器

​	Serial收集器是最基本、发展历史最悠久的收集器。在JDK1.3.1之前是虚拟机新生代收集的唯一选择。

	#### 1.特点-单线程

​	它是一个单线程的收集器，只使用一个CPU或一条收集线程去完成垃圾收集。更重要的是，它进行垃圾收集时，必须暂停其他所有的工作现场，直到它收集结束。

![java虚拟机图片10](/java虚拟机图片10.jpg)

​								Serial/Serial Old收集器运行示意图

####2.优点

​	在单线程或者说单CPU的环境中，它简单而高效，是虚拟机运行在Client模式下默认的新生代收集器。对于单CPU环境来说，Serial没有线程交互开销，专心做垃圾收集，从而获得最高的单线程收集效率。对于桌面应用来说，分配给虚拟机的内存不会太大，对于几十兆到几百兆的内存来说，停顿完全可以控制在几十毫秒到一百多毫秒，只要不是很频繁的进行垃圾收集，这个停顿完全可以接受。所以对于运行在Client模式下的虚拟机来说，Serial收集器是一个很好的选择。

### 3.5.3 ParNew收集器

​	ParNew收集器就是Serial收集器的一个多线程版本。

####1.特点1-多线程的Serial

​	除了多线程进行垃圾回收外，他的控制参数、收集算法、Stop The World、对象分配规则、回收策略等，都与Serial一致。实现上，这两种收集器共用了相当多的代码。

![java虚拟机图片11](/java虚拟机图片11.jpg)

​								ParNew/Serial Old收集器运行示意图

####2.特点2-除Serial外，只有它可以与CMS配合使用

​	ParNew是许多运行在Server模式下的虚拟机的首选新生代虚拟机，其中有一个与性能无关的原因是，除了Serial外，只有它可以与CMS搭配使用。如果使用CMS作为老年代收集器的话，就必须选择Serial或ParNew中的一个作为新生代收集器。使用-XX:+UseConcMarkSweepGC选项后的默认收集器就是ParNew。也可以使用-XX:+UseParNewGC来指定使用ParNew收集器。

####3.优点

​	在单CPU下，ParNew的效率不会比Serial高，甚至由于线程交互的开销，在双CPU下都不能百分之百的保证超过Serial。但是随着CPU数量的增加，它对于系统资源的有效利用还是能带来很多好处。它默认开启的线程数与CPU数量相同，在CPU非常多的情况下，可以通过-XX:ParallelGCThreads参数来限制垃圾收集器的线程数。

### 3.5.4 Parallel Scavenge收集器

​	Parallel Scavenge收集器是一个使用复制算法的多线程新生代收集器。

#### 1.特点-可控制吞吐量

​	其他收集器的关注点在于尽量缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的是达到一个可控制的吞吐量。由于与吞吐量关系密切，Parallel Scavenge收集器也经常称为“吞吐量优先”收集器。

​	停顿时间越短就越适合与用户交互的程序，良好的响应时间能够提升用户的体验。而高的吞吐量则可以保证CPU的高效率利用，尽快完成运算任何。主要适合在后台运算，没有太多交互任务的程序。

​	Parallel Scavenge收集器提供两个参数以精确控制吞吐量。

​	（1）-XX:MaxGCPauseMillis

​	用于控制最大的垃圾收集停顿时间，允许值是一个大于0的毫秒数，收集器将尽可能的保证不超过设定值。但是值越小并不意味着垃圾收集越快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的。

​	例如，把原来500MB的新生代减小为300MB，使收集更快。但是垃圾收集会发生的更频繁，原来10秒执行一次垃圾收集，一次持续100毫秒，现在5秒执行一次垃圾收集，一次执行70毫秒。停顿时间短了，但是吞吐量也下降了。

​	（2）-XX:GCTimeRatio

​	用于直接设置吞吐量大小 ，值是一个大于0且小于100的整数，用于表示垃圾收集时间所占的比率。假设 GCTimeRatio 的值为 n，那么系统将花费不超过 1/(1+n) 的时间用于垃圾收集。

​	 即垃圾收集时间/总时间<=1/(1+n)。这个参数的默认值为99，就是允许最大1%（即1/（1+99））的垃圾收集
时间。

####2.特点-自适应调节

​	Parallel Scavenge收集器还有一个参数-XX：+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象年龄（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。

####3.优点

​	如果读者对于收集器运作原来不太了解，手工优化存在困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGCPauseMillis参数（更关注最大停顿时间）或GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。

​	自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。

###3.5.5 Serial Old收集器

​	Serial Old收集器是Serial收集器的老年代版本，同样是单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。

​	如果在在Server模式下使用，主要有两大用途：

​	1.在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用 。

​	2.作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。

![java虚拟机图片10](/java虚拟机图片10.jpg)

​								Serial/Serial Old收集器运行示意图

**说明**：Parallel Scavenge收集器架构中本身有PS MarkSweep收集器来进行老年代收集，并非直接使用了Serial Old收集器，但是这个PS MarkSweep收集器与Serial Old的实现非常接近，所以在官方的许多资料中都是直接以Serial Old代替PS MarkSweep进行讲解。

###3.5.6 Parallel Old收集器

​	Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择。

​	由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。

​	直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。

![java虚拟机图片12](/java虚拟机图片12.jpg)

​					Parallel Scavenge/Parallel Old收集器运行示意图

###3.5.7 CMS收集器

​	CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种集器来说更复杂一些，整个过程分为6个步骤：

####3.5.7.1 回收过程

​	1.初始标记（CMS initial mark）

​	在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The Word)。这个过程从垃圾回收的"根对象"开始，只扫描到能够和"根对象"直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。

​	2.并发标记（CMS concurrent mark）

​	这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。

​	3.并发预处清理（CMS concurrent preclean）

​	由于CMS的目的是为了获得最短停顿时间，而接下来的重新标记阶段要STW，所以这个阶段的目的就是做尽可能多的工作来减少重新标记阶段停顿的时间。此阶段标记从新生代晋升的对象、新分配到老年代的对象以及在并发阶段被修改了的对象。

​	在这个阶段要确保被标记的对象都是存活的，那么就需要全量的扫描新生代和老年代，而这个过程显然会很慢，所以就必须要有一个能够快速识别新生代和老年代对象活着的机制。

​	（1）新生代

​	首先，我们知道新生代进行一次垃圾回收之后能够存活下来的对象很少，那么在扫描新生代之前进行一次Minor GC（新生代垃圾回收），扫描新生代的工作量就会减少很多。

​	CMS提供了两个参数CMSScheduleRemarkEdenSizeThreshold和CMSScheduleRemarkEdenPenetration，默认值分别是2M和50%。两个参数组合起来意味着预清理后，eden空间使用超过2M时启动可中断的并发预清理（CMS-concurrent-abortable-preclean），直到eden空间使用率达到50%时中断，进入remark阶段。

​	如果在这个过程中进行了一次Minor GC，那么就万事大吉了。但是我们是不能保证一定会执行Minor GC的，垃圾回收是JVM自动调度的，我们不能一直等待虚拟机执行Minor GC，所以CMS提供了一个参数CMSMaxAbortablePrecleanTime，默认值为5S。只要到了5S，不管发没发生Minor GC，有没有到CMSScheduleRemardEdenPenetration都会中止此阶段，进入remark。如果这5S内没有执行Minor GC，CMS提供了CMSScavengeBeforeRemark参数，使remark前强制进行一次Minor GC。但是这样做的好处是执行过一次Minor GC后，remake阶段停顿较短。但是同样的Minor GC需要停顿，紧跟的remake阶段也需要停顿，所以停顿的时间依然较长。

​	预清理阶段会尽可能多做一些事情来减少remark停顿时间。remark的rescan阶段是多线程的，为了便于多线程扫描新生代，**预清理阶段会将新生代分块**。每个块中存放着多个对象，这样remark阶段就不需要从头开始识别每个对象的起始位置。多个线程的职责就很明确了，把分块分配给多个线程，很快就扫描完。遗憾的是，这种办法仍然是建立在发生了Minor GC的条件下。如果没有发生Minor GC，top（下一个可以分配的地址空间）以下的所有空间被认为是一个块(这个块包含了新生代大部分内容)。这种块对于remark阶段并不会起到多少作用，因此并行效率也会降低。

​	（2）老年代

​	老年代的机制与一个叫**CARD TABLE**的东西（这个东西其实就是个数组,数组中每个位置存的是一个byte）密不可分。

​	CMS将老年代的空间分成大小为512bytes的块，card table中的每个元素对应着一个块。

​	并发标记时，如果某个对象的引用发生了变化，就标记该对象所在的块为  **dirty card**。

​	并发预清理阶段就会重新扫描该块，将该对象引用的对象标识为可达。

​	举个例子：

​	并发标记时对象的状态：![CMS老年代回收机制-1](/CMS老年代回收机制-1.png)

​	随后current obj的引用发生了变化，current obj所在的块被标记为了dirty card。

​	![CMS老年代回收机制-2](/CMS老年代回收机制-2.png)

​	随后到了pre-cleaning阶段，会对这些在并发标记阶段被修改的对象进行重新标记，同时清除dirty card标志

​	![CMS老年代回收机制-3](/CMS老年代回收机制-3.png)

​	除了标记在并发标记过程中被修改的对象外，dirty Card还可以用来对老年代引用新生代进行标记（老年代引用新生代这种场景不足1%）。这样，在Minor GC过程中通过扫描dirty card就可以快速识别被老年代引用的新生代对象。

​	4.重新标记（CMS remark）

​	这个阶段会Stop The World，收集器线程扫描在CMS堆中剩余的对象。扫描从"根对象"开始向下追溯，并处理对象关联。由于有了前面做的大量的工作，所以这个过程中停顿的时间也会减少。注意，这个过程是多线程的。

​	5.并发清理（Concurrent sweeping）

​	这个阶段会清理那些无效的对象。这个过程中用户线程会被激活，用户线程和GC线程是并发执行的。

​	6.并发重置（Concurrent reset）	

​	这个阶段并发执行，重新设置CMS算法内部的数据结构，准备下一个CMS生命周期的使用。

![CMS收集器运行示意图](/CMS收集器运行示意图.png)

#### 3.5.7.2 缺点

​	CMS是一款优秀的垃圾收集器，优点在于并发收集、低停顿。在Sun公司的一些官方文档中也被称为并发低停顿收集器。但是CMS还远远达不到完美的程度，还有很多缺点。

​	1.消耗较多的CPU资源

​	虽然CMS将大量的工作放在并发阶段执行，尽可能的减少STW的时间，但是并发阶段依然会占用一部分CPU资源导致程序变慢，程序的总吞吐量变低。

​	CMS默认的线程数是(CPU数量+3)/4，也就是当CPU在4个以上时，垃圾收集线程至少会占用25%以上的CPU资源。但是如果CPU数量少于4个，那么垃圾收集线程对资源的占用就会对用户线程造成很大的影响。虚拟机提供了一种“增量式并发收集器”（i-CMS，CMS收集器的变种），通过垃圾收集线程和用户线程交替执行来实现并发。虽然这样会减少垃圾收集线程占用CPU资源对用户线程的影响，但是会导致垃圾收集时间变长，i-CMS的效果一般，不提倡使用。但是现在的服务器几乎不会出现CPU少于4个的情况。

​	2.无法处理浮动垃圾

​	有CMS并发清理阶段是和用户线程并发执行的，这时候程序也会不断产生新的垃圾，而这部分新的垃圾是标记阶段之后产生的，CMS不能在本次收集中处理他们，需要到下一次GC才能处理，这部分垃圾称为浮动垃圾（Floating Garbage）。

​	由于清理过程和用户线程是并发执行的，所以不能等到老年代全部使用了再开始垃圾回收，要预留一部分内存给并发清理阶段的用户线程使用。在JDK1.5时，当老年代使用了68%就会激活GC，这是一个相对保守的设置。如果老年代增长不是太快，可以通过CMSInitiatingOccupancyFraction参数调高触发百分比，以便降低内存回收次数从而提高程序运行效率。在JDK1.6中，这个值已经被提高到了92%。

​	虽然调高触发的百分比可以减少内存收集次数，提升程序性能，但是如果预留的这部分内存无法满足CMS运行期间的程序需求，就会出现Concurrent  Mode Failure错误。这时虚拟机就会启动后备方案：临时启用Serial Old收集器对老年代进行回收，这样就会停顿很长时间。所以CMSInitiatingOccupancyFraction的值需要根据实际情况分析确定，如果设置的太高会导致频繁出现Concurrent  Mode Failure导致性能降低。

​	其实CMS有动态检查机制，CMS会根据历史记录，预测老年代还需要多久填满及进行一次回收所需要的时间。在老年代空间用完之前，CMS可以根据自己的预测自动执行垃圾回收。这个特性可以使用参数UseCMSInitiatingOccupancyOnly来关闭。

​	3.内存碎片

​	CMS是基于“标记-清除”算法的，这意味着收集结束会产生大量的内存碎片。如果空间碎片过多，在对象分配的时候，就会出现即使还有大量的内存空间，但是找不出一个连续的空间来分配给当前对象。这样虚拟机就会触发一次Full GC。

​	CMS的解决方案是使用UseCMSCompactAtFullCollection参数(默认开启)，在顶不住要进行Full GC时开启内存碎片整理。这个过程需要STW，碎片问题解决了,但停顿时间又变长了。

​	虚拟机还提供了另外一个参数CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认为0，每次进入Full GC时都进行碎片整理）。

### 3.5.8 G1收集器

​	G1（Garbage-Frist）收集器是一款面向服务器端应用的垃圾收集器。HotSpot团队的预期是在未来用G1替换掉CMS收集器。

#### 3.5.8.1 特点

​	1.并行与并发

​	G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。

​	2.分代收集

​	与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆（既能处理新生代又能处理老年代），但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。

​	3.空间整合

​	与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。

​	4.可预测的停顿

​	这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

